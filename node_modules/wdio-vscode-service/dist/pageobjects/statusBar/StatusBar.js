var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { PageDecorator, BasePage } from '../utils.js';
import { StatusBar as StatusBarLocators } from '../../locators/1.73.0.js';
import { NotificationsCenter } from '../index.js';
/**
 * Page object for the status bar at the bottom
 *
 * @category Statusbar
 */
export let StatusBar = class StatusBar extends BasePage {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'StatusBar';
    }
    /**
     * Retrieve all status bar items currently displayed
     * @returns Promise resolving to an array of WebElement
     */
    async getItems() {
        const elems = await this.item$$;
        const items = [];
        for (const elem of elems) {
            items.push(await elem.getAttribute(this.locators.itemTitle));
        }
        return items.map((i) => i.trim()).filter(Boolean);
    }
    /**
     * Find status bar item by title/visible label
     * @param title title of the item
     * @returns Promise resolving to a WebElement if item is found, to undefined otherwise
     */
    async getItem(title) {
        const items = await this.item$$;
        for (const item of items) {
            if (await item.getAttribute(this.locators.itemTitle) === title) {
                return item;
            }
        }
        return undefined;
    }
    /**
     * Open the notifications center
     * @returns Promise resolving to NotificationsCenter object
     */
    async openNotificationsCenter() {
        await this.toggleNotificationsCentre(true);
        return new NotificationsCenter(this.locatorMap);
    }
    /**
     * Close the notifications center
     * @returns Promise resolving when the notifications center is closed
     */
    async closeNotificationsCenter() {
        await this.toggleNotificationsCentre(false);
    }
    /**
     * Open the language selection quick pick
     * Only works with an open editor
     * @returns Promise resolving when the language selection is opened
     */
    async openLanguageSelection() {
        await this.language$.click();
    }
    /**
     * Get the current language label text
     * Only works with an open editor
     * @returns Promise resolving to string representation of current language
     */
    async getCurrentLanguage() {
        return this.getPartText(this.locators.language);
    }
    /**
     * Open the quick pick for line endings selection
     * Only works with an open editor
     * @returns Promise resolving when the line ending selection is opened
     */
    async openLineEndingSelection() {
        await this.lines$.click();
    }
    /**
     * Get the currently selected line ending as text
     * Only works with an open editor
     * @returns Promise resolving to string representation of current line ending
     */
    async getCurrentLineEnding() {
        return this.getPartText(this.locators.lines);
    }
    /**
     * Open the encoding selection quick pick
     * Only works with an open editor
     * @returns Promise resolving when the encoding selection is opened
     */
    async openEncodingSelection() {
        await this.encoding$.click();
    }
    /**
     * Get the name of the current encoding as text
     * Only works with an open editor
     * @returns Promise resolving to string representation of current encoding
     */
    async getCurrentEncoding() {
        return this.getPartText(this.locators.encoding);
    }
    /**
     * Open the indentation selection quick pick
     * Only works with an open editor
     * @returns Promise resolving when the indentation selection is opened
     */
    async openIndentationSelection() {
        await this.indent$.click();
    }
    /**
     * Get the current indentation option label as text
     * Only works with an open editor
     * @returns Promise resolving to string representation of current indentation
     */
    async getCurrentIndentation() {
        return this.getPartText(this.locators.indent);
    }
    /**
     * Open the line selection input box
     * Only works with an open editor
     * @returns Promise resolving when the line selection is opened
     */
    async openLineSelection() {
        await this.selection$.click();
    }
    /**
     * Get the current editor coordinates as text
     * Only works with an open editor
     * @returns Promise resolving to string representation of current position in the editor
     */
    async getCurrentPosition() {
        return this.getPartText(this.locators.selection);
    }
    /**
     * Open/Close notification centre
     * @param open true to open, false to close
     */
    async toggleNotificationsCentre(open) {
        let visible = false;
        try {
            const klass = await browser
                .$(this.locatorMap.Workbench.elem)
                .$(this.locators.notifications)
                .getAttribute('class');
            visible = klass.indexOf('visible') > -1;
        }
        catch (err) {
            // element doesn't exist until the button is first clicked
        }
        if (visible !== open) {
            await this.bell$.click();
        }
    }
    async getPartText(locator) {
        return this.elem.$(locator).$('a').getText();
    }
};
StatusBar = __decorate([
    PageDecorator(StatusBarLocators)
], StatusBar);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3RhdHVzQmFyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3BhZ2VvYmplY3RzL3N0YXR1c0Jhci9TdGF0dXNCYXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsT0FBTyxFQUFFLGFBQWEsRUFBa0IsUUFBUSxFQUFFLE1BQU0sYUFBYSxDQUFBO0FBQ3JFLE9BQU8sRUFBRSxTQUFTLElBQUksaUJBQWlCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQTtBQUN6RSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxhQUFhLENBQUE7QUFHakQ7Ozs7R0FJRztBQUVJLFdBQU0sU0FBUyxHQUFmLE1BQU0sU0FBVSxTQUFRLFFBQWtDO0lBQTFEOztRQUNIOztXQUVHO1FBQ0ksZUFBVSxHQUFHLFdBQW9CLENBQUE7SUFnSzVDLENBQUM7SUE5Skc7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLFFBQVE7UUFDVixNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUE7UUFDL0IsTUFBTSxLQUFLLEdBQWEsRUFBRSxDQUFBO1FBQzFCLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFO1lBQ3RCLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQTtTQUMvRDtRQUNELE9BQU8sS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFBO0lBQ3JELENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLE9BQU8sQ0FBRSxLQUFhO1FBQ3hCLE1BQU0sS0FBSyxHQUFHLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQTtRQUMvQixLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRTtZQUN0QixJQUFJLE1BQU0sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEtBQUssRUFBRTtnQkFDNUQsT0FBTyxJQUFJLENBQUE7YUFDZDtTQUNKO1FBQ0QsT0FBTyxTQUFTLENBQUE7SUFDcEIsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyx1QkFBdUI7UUFDekIsTUFBTSxJQUFJLENBQUMseUJBQXlCLENBQUMsSUFBSSxDQUFDLENBQUE7UUFDMUMsT0FBTyxJQUFJLG1CQUFtQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQTtJQUNuRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLHdCQUF3QjtRQUMxQixNQUFNLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxLQUFLLENBQUMsQ0FBQTtJQUMvQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxxQkFBcUI7UUFDdkIsTUFBTSxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFBO0lBQ2hDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLGtCQUFrQjtRQUNwQixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQTtJQUNuRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyx1QkFBdUI7UUFDekIsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFBO0lBQzdCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLG9CQUFvQjtRQUN0QixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQTtJQUNoRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxxQkFBcUI7UUFDdkIsTUFBTSxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFBO0lBQ2hDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLGtCQUFrQjtRQUNwQixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQTtJQUNuRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyx3QkFBd0I7UUFDMUIsTUFBTSxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFBO0lBQzlCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLHFCQUFxQjtRQUN2QixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQTtJQUNqRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxpQkFBaUI7UUFDbkIsTUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFBO0lBQ2pDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLGtCQUFrQjtRQUNwQixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQTtJQUNwRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssS0FBSyxDQUFDLHlCQUF5QixDQUFFLElBQWE7UUFDbEQsSUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFBO1FBQ25CLElBQUk7WUFDQSxNQUFNLEtBQUssR0FBRyxNQUFNLE9BQU87aUJBQ3RCLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxJQUFjLENBQUM7aUJBQzNDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQztpQkFDOUIsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFBO1lBQzFCLE9BQU8sR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFBO1NBQzFDO1FBQUMsT0FBTyxHQUFHLEVBQUU7WUFDViwwREFBMEQ7U0FDN0Q7UUFDRCxJQUFJLE9BQU8sS0FBSyxJQUFJLEVBQUU7WUFDbEIsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFBO1NBQzNCO0lBQ0wsQ0FBQztJQUVPLEtBQUssQ0FBQyxXQUFXLENBQUUsT0FBZTtRQUN0QyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQTtJQUNoRCxDQUFDO0NBQ0osQ0FBQTtBQXBLWSxTQUFTO0lBRHJCLGFBQWEsQ0FBQyxpQkFBaUIsQ0FBQztHQUNwQixTQUFTLENBb0tyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhZ2VEZWNvcmF0b3IsIElQYWdlRGVjb3JhdG9yLCBCYXNlUGFnZSB9IGZyb20gJy4uL3V0aWxzLmpzJ1xuaW1wb3J0IHsgU3RhdHVzQmFyIGFzIFN0YXR1c0JhckxvY2F0b3JzIH0gZnJvbSAnLi4vLi4vbG9jYXRvcnMvMS43My4wLmpzJ1xuaW1wb3J0IHsgTm90aWZpY2F0aW9uc0NlbnRlciB9IGZyb20gJy4uL2luZGV4LmpzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXR1c0JhciBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBTdGF0dXNCYXJMb2NhdG9ycz4ge31cbi8qKlxuICogUGFnZSBvYmplY3QgZm9yIHRoZSBzdGF0dXMgYmFyIGF0IHRoZSBib3R0b21cbiAqXG4gKiBAY2F0ZWdvcnkgU3RhdHVzYmFyXG4gKi9cbkBQYWdlRGVjb3JhdG9yKFN0YXR1c0JhckxvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIFN0YXR1c0JhciBleHRlbmRzIEJhc2VQYWdlPHR5cGVvZiBTdGF0dXNCYXJMb2NhdG9ycz4ge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnU3RhdHVzQmFyJyBhcyBjb25zdFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYWxsIHN0YXR1cyBiYXIgaXRlbXMgY3VycmVudGx5IGRpc3BsYXllZFxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGFuIGFycmF5IG9mIFdlYkVsZW1lbnRcbiAgICAgKi9cbiAgICBhc3luYyBnZXRJdGVtcyAoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1zID0gYXdhaXQgdGhpcy5pdGVtJCRcbiAgICAgICAgY29uc3QgaXRlbXM6IHN0cmluZ1tdID0gW11cbiAgICAgICAgZm9yIChjb25zdCBlbGVtIG9mIGVsZW1zKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGF3YWl0IGVsZW0uZ2V0QXR0cmlidXRlKHRoaXMubG9jYXRvcnMuaXRlbVRpdGxlKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbXMubWFwKChpKSA9PiBpLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBzdGF0dXMgYmFyIGl0ZW0gYnkgdGl0bGUvdmlzaWJsZSBsYWJlbFxuICAgICAqIEBwYXJhbSB0aXRsZSB0aXRsZSBvZiB0aGUgaXRlbVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGEgV2ViRWxlbWVudCBpZiBpdGVtIGlzIGZvdW5kLCB0byB1bmRlZmluZWQgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SXRlbSAodGl0bGU6IHN0cmluZykge1xuICAgICAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHRoaXMuaXRlbSQkXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgaWYgKGF3YWl0IGl0ZW0uZ2V0QXR0cmlidXRlKHRoaXMubG9jYXRvcnMuaXRlbVRpdGxlKSA9PT0gdGl0bGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoZSBub3RpZmljYXRpb25zIGNlbnRlclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIE5vdGlmaWNhdGlvbnNDZW50ZXIgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgb3Blbk5vdGlmaWNhdGlvbnNDZW50ZXIgKCk6IFByb21pc2U8Tm90aWZpY2F0aW9uc0NlbnRlcj4ge1xuICAgICAgICBhd2FpdCB0aGlzLnRvZ2dsZU5vdGlmaWNhdGlvbnNDZW50cmUodHJ1ZSlcbiAgICAgICAgcmV0dXJuIG5ldyBOb3RpZmljYXRpb25zQ2VudGVyKHRoaXMubG9jYXRvck1hcClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgbm90aWZpY2F0aW9ucyBjZW50ZXJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBub3RpZmljYXRpb25zIGNlbnRlciBpcyBjbG9zZWRcbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZU5vdGlmaWNhdGlvbnNDZW50ZXIgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCB0aGlzLnRvZ2dsZU5vdGlmaWNhdGlvbnNDZW50cmUoZmFsc2UpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbiB0aGUgbGFuZ3VhZ2Ugc2VsZWN0aW9uIHF1aWNrIHBpY2tcbiAgICAgKiBPbmx5IHdvcmtzIHdpdGggYW4gb3BlbiBlZGl0b3JcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBsYW5ndWFnZSBzZWxlY3Rpb24gaXMgb3BlbmVkXG4gICAgICovXG4gICAgYXN5bmMgb3Blbkxhbmd1YWdlU2VsZWN0aW9uICgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5sYW5ndWFnZSQuY2xpY2soKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBsYW5ndWFnZSBsYWJlbCB0ZXh0XG4gICAgICogT25seSB3b3JrcyB3aXRoIGFuIG9wZW4gZWRpdG9yXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGN1cnJlbnQgbGFuZ3VhZ2VcbiAgICAgKi9cbiAgICBhc3luYyBnZXRDdXJyZW50TGFuZ3VhZ2UgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhcnRUZXh0KHRoaXMubG9jYXRvcnMubGFuZ3VhZ2UpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbiB0aGUgcXVpY2sgcGljayBmb3IgbGluZSBlbmRpbmdzIHNlbGVjdGlvblxuICAgICAqIE9ubHkgd29ya3Mgd2l0aCBhbiBvcGVuIGVkaXRvclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGxpbmUgZW5kaW5nIHNlbGVjdGlvbiBpcyBvcGVuZWRcbiAgICAgKi9cbiAgICBhc3luYyBvcGVuTGluZUVuZGluZ1NlbGVjdGlvbiAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGF3YWl0IHRoaXMubGluZXMkLmNsaWNrKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBsaW5lIGVuZGluZyBhcyB0ZXh0XG4gICAgICogT25seSB3b3JrcyB3aXRoIGFuIG9wZW4gZWRpdG9yXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGN1cnJlbnQgbGluZSBlbmRpbmdcbiAgICAgKi9cbiAgICBhc3luYyBnZXRDdXJyZW50TGluZUVuZGluZyAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFydFRleHQodGhpcy5sb2NhdG9ycy5saW5lcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoZSBlbmNvZGluZyBzZWxlY3Rpb24gcXVpY2sgcGlja1xuICAgICAqIE9ubHkgd29ya3Mgd2l0aCBhbiBvcGVuIGVkaXRvclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGVuY29kaW5nIHNlbGVjdGlvbiBpcyBvcGVuZWRcbiAgICAgKi9cbiAgICBhc3luYyBvcGVuRW5jb2RpbmdTZWxlY3Rpb24gKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCB0aGlzLmVuY29kaW5nJC5jbGljaygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGVuY29kaW5nIGFzIHRleHRcbiAgICAgKiBPbmx5IHdvcmtzIHdpdGggYW4gb3BlbiBlZGl0b3JcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgY3VycmVudCBlbmNvZGluZ1xuICAgICAqL1xuICAgIGFzeW5jIGdldEN1cnJlbnRFbmNvZGluZyAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFydFRleHQodGhpcy5sb2NhdG9ycy5lbmNvZGluZylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoZSBpbmRlbnRhdGlvbiBzZWxlY3Rpb24gcXVpY2sgcGlja1xuICAgICAqIE9ubHkgd29ya3Mgd2l0aCBhbiBvcGVuIGVkaXRvclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGluZGVudGF0aW9uIHNlbGVjdGlvbiBpcyBvcGVuZWRcbiAgICAgKi9cbiAgICBhc3luYyBvcGVuSW5kZW50YXRpb25TZWxlY3Rpb24gKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCB0aGlzLmluZGVudCQuY2xpY2soKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBvcHRpb24gbGFiZWwgYXMgdGV4dFxuICAgICAqIE9ubHkgd29ya3Mgd2l0aCBhbiBvcGVuIGVkaXRvclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBjdXJyZW50IGluZGVudGF0aW9uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q3VycmVudEluZGVudGF0aW9uICgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXJ0VGV4dCh0aGlzLmxvY2F0b3JzLmluZGVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoZSBsaW5lIHNlbGVjdGlvbiBpbnB1dCBib3hcbiAgICAgKiBPbmx5IHdvcmtzIHdpdGggYW4gb3BlbiBlZGl0b3JcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBsaW5lIHNlbGVjdGlvbiBpcyBvcGVuZWRcbiAgICAgKi9cbiAgICBhc3luYyBvcGVuTGluZVNlbGVjdGlvbiAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VsZWN0aW9uJC5jbGljaygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGVkaXRvciBjb29yZGluYXRlcyBhcyB0ZXh0XG4gICAgICogT25seSB3b3JrcyB3aXRoIGFuIG9wZW4gZWRpdG9yXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIGVkaXRvclxuICAgICAqL1xuICAgIGFzeW5jIGdldEN1cnJlbnRQb3NpdGlvbiAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFydFRleHQodGhpcy5sb2NhdG9ycy5zZWxlY3Rpb24pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3Blbi9DbG9zZSBub3RpZmljYXRpb24gY2VudHJlXG4gICAgICogQHBhcmFtIG9wZW4gdHJ1ZSB0byBvcGVuLCBmYWxzZSB0byBjbG9zZVxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgdG9nZ2xlTm90aWZpY2F0aW9uc0NlbnRyZSAob3BlbjogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBsZXQgdmlzaWJsZSA9IGZhbHNlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBrbGFzcyA9IGF3YWl0IGJyb3dzZXJcbiAgICAgICAgICAgICAgICAuJCh0aGlzLmxvY2F0b3JNYXAuV29ya2JlbmNoLmVsZW0gYXMgc3RyaW5nKVxuICAgICAgICAgICAgICAgIC4kKHRoaXMubG9jYXRvcnMubm90aWZpY2F0aW9ucylcbiAgICAgICAgICAgICAgICAuZ2V0QXR0cmlidXRlKCdjbGFzcycpXG4gICAgICAgICAgICB2aXNpYmxlID0ga2xhc3MuaW5kZXhPZigndmlzaWJsZScpID4gLTFcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBlbGVtZW50IGRvZXNuJ3QgZXhpc3QgdW50aWwgdGhlIGJ1dHRvbiBpcyBmaXJzdCBjbGlja2VkXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpc2libGUgIT09IG9wZW4pIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYmVsbCQuY2xpY2soKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRQYXJ0VGV4dCAobG9jYXRvcjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbS4kKGxvY2F0b3IpLiQoJ2EnKS5nZXRUZXh0KClcbiAgICB9XG59XG4iXX0=