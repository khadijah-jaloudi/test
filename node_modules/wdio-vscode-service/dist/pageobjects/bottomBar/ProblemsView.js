var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { BottomBarPanel } from '../index.js';
import { BasePage, ElementWithContextMenu, PageDecorator } from '../utils.js';
import { ProblemsView as ProblemsViewLocators, Marker as MarkerLocators } from '../../locators/1.73.0.js';
/**
 * Problems view in the bottom panel.
 *
 * ```ts
 * const bottomBar = workbench.getBottomBar()
 * const outputView = await bottomBar.openProblemsView()
 * console.log(await outputView.setFilter('Error'))
 * ```
 *
 * @category BottomBar
 */
export let ProblemsView = class ProblemsView extends BasePage {
    constructor(locators, panel = new BottomBarPanel(locators)) {
        super(locators);
        this.panel = panel;
        /**
         * @private
         */
        this.locatorKey = 'ProblemsView';
        this.setParentElement(this.panel.elem);
    }
    /**
     * Set the filter using the input box on the problems view
     * @param pattern filter to use, preferably a glob pattern
     * @returns Promise resolving when the filter pattern is filled in
     */
    async setFilter(pattern) {
        const filterField = await this.clearFilter();
        await filterField.setValue(pattern);
    }
    /**
     * Clear all filters
     * @returns Promise resolving to the filter field WebElement
     */
    async clearFilter() {
        const filterField = await this.panel.elem
            .$(this.locatorMap.BottomBarPanel.actions)
            .$(this.locators.markersFilter)
            .$(this.locators.input);
        await filterField.clearValue();
        return filterField;
    }
    /**
     * Collapse all collapsible markers in the problems view
     * @returns Promise resolving when the collapse all button is pressed
     */
    async collapseAll() {
        const button = await this.panel.elem
            .$(this.locatorMap.BottomBarPanel.actions)
            .$(this.locators.collapseAll);
        await button.click();
    }
    /**
     * @deprecated The method should not be used and getAllVisibleMarkers() should be used instead.
     */
    async getAllMarkers() {
        return this.getAllVisibleMarkers(MarkerType.Any);
    }
    /**
     * Get all visible markers from the problems view with the given type.
     * Warning: this only returns the markers that are visible, and not the
     * entire list, so calls to this function may change depending on the
     * environment  in which the tests are running in.
     * To get all markers regardless of type, use MarkerType.Any
     * @param type type of markers to retrieve
     * @returns Promise resolving to array of Marker objects
     */
    async getAllVisibleMarkers(type) {
        const markers = [];
        const elements = await this.markerRow$$;
        for (const element of elements) {
            const isExpandable = typeof (await element.getAttribute('aria-expanded')) === 'string';
            if (isExpandable) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                const marker = await new Marker(this.locatorMap, element, this).wait();
                if (type === MarkerType.Any || type === await marker.getType()) {
                    markers.push(marker);
                }
                continue;
            }
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            markers[markers.length - 1].problems.push(new Problem(this.locatorMap, element));
        }
        return markers;
    }
    /**
     * Gets the count badge
     * @returns Promise resolving to the WebElement representing the count badge
     */
    getCountBadge() {
        return this.changeCount$;
    }
};
ProblemsView = __decorate([
    PageDecorator(ProblemsViewLocators)
], ProblemsView);
/**
 * Page object for marker in problems view
 *
 * @category BottomBar
 */
export let Marker = class Marker extends ElementWithContextMenu {
    constructor(locators, element, view) {
        super(locators, element, view.elem);
        this.view = view;
        /**
         * @private
         */
        this.locatorKey = 'Marker';
        this.problems = [];
    }
    /**
     * Get the type of the marker
     * Possible types are: File, Error, Warning
     * @returns Promise resolving to a MarkerType
     */
    async getType() {
        const twist = await this.elem.$(this.locatorMap.ProblemsView.markerTwistie);
        if ((await twist.getAttribute('class')).indexOf('collapsible') > -1) {
            return MarkerType.File;
        }
        const text = await this.getText();
        if (text.startsWith('Error')) {
            return MarkerType.Error;
        }
        return MarkerType.Warning;
    }
    /**
     * Get the name of the file that has problems
     * @returns name of file containing problems
     */
    getFileName() {
        return this.fileName$.getText();
    }
    /**
     * Get the error count of the file that has problems
     * @returns error count of file containing problems
     */
    getProblemCount() {
        return this.problemCount$.getText();
    }
    /**
     * Get the full text of the marker
     * @returns Promise resolving to marker text
     */
    async getText() {
        return this.elem.getAttribute(this.locators.rowLabel);
    }
    /**
     * Expand/Collapse the marker if possible
     * @param expand true to expand, false to collapse
     * @returns Promise resolving when the expand/collapse twistie is clicked
     */
    async toggleExpand(expand) {
        const klass = await this.markerTwistie$.getAttribute('class');
        if ((klass.indexOf('collapsed') > -1) === expand) {
            await this.elem.click();
        }
    }
};
Marker = __decorate([
    PageDecorator(MarkerLocators)
], Marker);
/**
 * Page object for marker in problems view
 *
 * @category BottomBar
 */
export let Problem = class Problem extends ElementWithContextMenu {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'Marker';
    }
    /**
     * Problem details
     * @returns problem description
     */
    getText() {
        return this.detailsText$.getText();
    }
    /**
     * Type of file where the problem is located
     * @returns source file type
     */
    getSource() {
        return this.detailsSource$.getText();
    }
    /**
     * Location problem
     * @returns location of error as Array [line, column]
     */
    async getLocation() {
        const locationText = await this.detailsLine$.getText();
        return locationText
            .slice(1, -1)
            .split(',')
            .map((loc) => parseInt(loc.split(' ').pop(), 10));
    }
    /**
     * Get the type of the marker
     * Possible types are: File, Error, Warning
     * @returns Promise resolving to a MarkerType
     */
    async getType() {
        const label = await this.elem.getAttribute('aria-label');
        if (!label) {
            return MarkerType.Unknown;
        }
        if (label.startsWith('Error')) {
            return MarkerType.Error;
        }
        return MarkerType.Warning;
    }
};
Problem = __decorate([
    PageDecorator(MarkerLocators)
], Problem);
/**
 * Possible types of markers
 *  - File = expandable item representing a file
 *  - Error = an error marker
 *  - Warning = a warning marker
 *  - Any = any of the above
 *
 * @hidden
 */
export var MarkerType;
(function (MarkerType) {
    MarkerType["File"] = "file";
    MarkerType["Unknown"] = "unknown";
    MarkerType["Error"] = "error";
    MarkerType["Warning"] = "warning";
    MarkerType["Any"] = "any";
})(MarkerType || (MarkerType = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJvYmxlbXNWaWV3LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3BhZ2VvYmplY3RzL2JvdHRvbUJhci9Qcm9ibGVtc1ZpZXcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRUEsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGFBQWEsQ0FBQTtBQUM1QyxPQUFPLEVBQ0gsUUFBUSxFQUFFLHNCQUFzQixFQUFFLGFBQWEsRUFDbEQsTUFBTSxhQUFhLENBQUE7QUFDcEIsT0FBTyxFQUFFLFlBQVksSUFBSSxvQkFBb0IsRUFBRSxNQUFNLElBQUksY0FBYyxFQUFFLE1BQU0sMEJBQTBCLENBQUE7QUFHekc7Ozs7Ozs7Ozs7R0FVRztBQUVJLFdBQU0sWUFBWSxHQUFsQixNQUFNLFlBQWEsU0FBUSxRQUFxQztJQU1uRSxZQUNJLFFBQTBCLEVBQ25CLFFBQVEsSUFBSSxjQUFjLENBQUMsUUFBUSxDQUFDO1FBRTNDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQTtRQUZSLFVBQUssR0FBTCxLQUFLLENBQStCO1FBUC9DOztXQUVHO1FBQ0ksZUFBVSxHQUFHLGNBQXVCLENBQUE7UUFPdkMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUE7SUFDMUMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsU0FBUyxDQUFFLE9BQWU7UUFDNUIsTUFBTSxXQUFXLEdBQUcsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUE7UUFDNUMsTUFBTSxXQUFXLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFBO0lBQ3ZDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsV0FBVztRQUNiLE1BQU0sV0FBVyxHQUFHLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJO2FBQ3BDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxPQUFpQixDQUFD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LFVBTVg7QUFORCxXQUFZLFVBQVU7SUFDbEIsMkJBQWEsQ0FBQTtJQUNiLGlDQUFtQixDQUFBO0lBQ25CLDZCQUFlLENBQUE7SUFDZixpQ0FBbUIsQ0FBQTtJQUNuQix5QkFBVyxDQUFBO0FBQ2YsQ0FBQyxFQU5XLFVBQVUsS0FBVixVQUFVLFFBTXJCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDaGFpbmFibGVQcm9taXNlRWxlbWVudCB9IGZyb20gJ3dlYmRyaXZlcmlvJ1xuXG5pbXBvcnQgeyBCb3R0b21CYXJQYW5lbCB9IGZyb20gJy4uL2luZGV4LmpzJ1xuaW1wb3J0IHtcbiAgICBCYXNlUGFnZSwgRWxlbWVudFdpdGhDb250ZXh0TWVudSwgUGFnZURlY29yYXRvciwgSVBhZ2VEZWNvcmF0b3IsIFZTQ29kZUxvY2F0b3JNYXBcbn0gZnJvbSAnLi4vdXRpbHMuanMnXG5pbXBvcnQgeyBQcm9ibGVtc1ZpZXcgYXMgUHJvYmxlbXNWaWV3TG9jYXRvcnMsIE1hcmtlciBhcyBNYXJrZXJMb2NhdG9ycyB9IGZyb20gJy4uLy4uL2xvY2F0b3JzLzEuNzMuMC5qcydcblxuZXhwb3J0IGludGVyZmFjZSBQcm9ibGVtc1ZpZXcgZXh0ZW5kcyBJUGFnZURlY29yYXRvcjx0eXBlb2YgUHJvYmxlbXNWaWV3TG9jYXRvcnM+IHt9XG4vKipcbiAqIFByb2JsZW1zIHZpZXcgaW4gdGhlIGJvdHRvbSBwYW5lbC5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgYm90dG9tQmFyID0gd29ya2JlbmNoLmdldEJvdHRvbUJhcigpXG4gKiBjb25zdCBvdXRwdXRWaWV3ID0gYXdhaXQgYm90dG9tQmFyLm9wZW5Qcm9ibGVtc1ZpZXcoKVxuICogY29uc29sZS5sb2coYXdhaXQgb3V0cHV0Vmlldy5zZXRGaWx0ZXIoJ0Vycm9yJykpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgQm90dG9tQmFyXG4gKi9cbkBQYWdlRGVjb3JhdG9yKFByb2JsZW1zVmlld0xvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIFByb2JsZW1zVmlldyBleHRlbmRzIEJhc2VQYWdlPHR5cGVvZiBQcm9ibGVtc1ZpZXdMb2NhdG9ycz4ge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnUHJvYmxlbXNWaWV3JyBhcyBjb25zdFxuXG4gICAgY29uc3RydWN0b3IgKFxuICAgICAgICBsb2NhdG9yczogVlNDb2RlTG9jYXRvck1hcCxcbiAgICAgICAgcHVibGljIHBhbmVsID0gbmV3IEJvdHRvbUJhclBhbmVsKGxvY2F0b3JzKVxuICAgICkge1xuICAgICAgICBzdXBlcihsb2NhdG9ycylcbiAgICAgICAgdGhpcy5zZXRQYXJlbnRFbGVtZW50KHRoaXMucGFuZWwuZWxlbSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZpbHRlciB1c2luZyB0aGUgaW5wdXQgYm94IG9uIHRoZSBwcm9ibGVtcyB2aWV3XG4gICAgICogQHBhcmFtIHBhdHRlcm4gZmlsdGVyIHRvIHVzZSwgcHJlZmVyYWJseSBhIGdsb2IgcGF0dGVyblxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGZpbHRlciBwYXR0ZXJuIGlzIGZpbGxlZCBpblxuICAgICAqL1xuICAgIGFzeW5jIHNldEZpbHRlciAocGF0dGVybjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGZpbHRlckZpZWxkID0gYXdhaXQgdGhpcy5jbGVhckZpbHRlcigpXG4gICAgICAgIGF3YWl0IGZpbHRlckZpZWxkLnNldFZhbHVlKHBhdHRlcm4pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGZpbHRlcnNcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgZmlsdGVyIGZpZWxkIFdlYkVsZW1lbnRcbiAgICAgKi9cbiAgICBhc3luYyBjbGVhckZpbHRlciAoKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlckZpZWxkID0gYXdhaXQgdGhpcy5wYW5lbC5lbGVtXG4gICAgICAgICAgICAuJCh0aGlzLmxvY2F0b3JNYXAuQm90dG9tQmFyUGFuZWwuYWN0aW9ucyBhcyBzdHJpbmcpXG4gICAgICAgICAgICAuJCh0aGlzLmxvY2F0b3JzLm1hcmtlcnNGaWx0ZXIpXG4gICAgICAgICAgICAuJCh0aGlzLmxvY2F0b3JzLmlucHV0KVxuICAgICAgICBhd2FpdCBmaWx0ZXJGaWVsZC5jbGVhclZhbHVlKClcbiAgICAgICAgcmV0dXJuIGZpbHRlckZpZWxkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29sbGFwc2UgYWxsIGNvbGxhcHNpYmxlIG1hcmtlcnMgaW4gdGhlIHByb2JsZW1zIHZpZXdcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBjb2xsYXBzZSBhbGwgYnV0dG9uIGlzIHByZXNzZWRcbiAgICAgKi9cbiAgICBhc3luYyBjb2xsYXBzZUFsbCAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGJ1dHRvbiA9IGF3YWl0IHRoaXMucGFuZWwuZWxlbVxuICAgICAgICAgICAgLiQodGhpcy5sb2NhdG9yTWFwLkJvdHRvbUJhclBhbmVsLmFjdGlvbnMgYXMgc3RyaW5nKVxuICAgICAgICAgICAgLiQodGhpcy5sb2NhdG9ycy5jb2xsYXBzZUFsbClcbiAgICAgICAgYXdhaXQgYnV0dG9uLmNsaWNrKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGUgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZCBhbmQgZ2V0QWxsVmlzaWJsZU1hcmtlcnMoKSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFsbE1hcmtlcnMgKCk6IFByb21pc2U8TWFya2VyW10+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsVmlzaWJsZU1hcmtlcnMoTWFya2VyVHlwZS5BbnkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB2aXNpYmxlIG1hcmtlcnMgZnJvbSB0aGUgcHJvYmxlbXMgdmlldyB3aXRoIHRoZSBnaXZlbiB0eXBlLlxuICAgICAqIFdhcm5pbmc6IHRoaXMgb25seSByZXR1cm5zIHRoZSBtYXJrZXJzIHRoYXQgYXJlIHZpc2libGUsIGFuZCBub3QgdGhlXG4gICAgICogZW50aXJlIGxpc3QsIHNvIGNhbGxzIHRvIHRoaXMgZnVuY3Rpb24gbWF5IGNoYW5nZSBkZXBlbmRpbmcgb24gdGhlXG4gICAgICogZW52aXJvbm1lbnQgIGluIHdoaWNoIHRoZSB0ZXN0cyBhcmUgcnVubmluZyBpbi5cbiAgICAgKiBUbyBnZXQgYWxsIG1hcmtlcnMgcmVnYXJkbGVzcyBvZiB0eXBlLCB1c2UgTWFya2VyVHlwZS5BbnlcbiAgICAgKiBAcGFyYW0gdHlwZSB0eXBlIG9mIG1hcmtlcnMgdG8gcmV0cmlldmVcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhcnJheSBvZiBNYXJrZXIgb2JqZWN0c1xuICAgICAqL1xuICAgIGFzeW5jIGdldEFsbFZpc2libGVNYXJrZXJzICh0eXBlOiBNYXJrZXJUeXBlKTogUHJvbWlzZTxNYXJrZXJbXT4ge1xuICAgICAgICBjb25zdCBtYXJrZXJzOiBNYXJrZXJbXSA9IFtdXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gYXdhaXQgdGhpcy5tYXJrZXJSb3ckJFxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzRXhwYW5kYWJsZSA9IHR5cGVvZiAoYXdhaXQgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKSkgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICBpZiAoaXNFeHBhbmRhYmxlKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBhd2FpdCBuZXcgTWFya2VyKHRoaXMubG9jYXRvck1hcCwgZWxlbWVudCBhcyBhbnksIHRoaXMpLndhaXQoKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBNYXJrZXJUeXBlLkFueSB8fCB0eXBlID09PSBhd2FpdCBtYXJrZXIuZ2V0VHlwZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlcnMucHVzaChtYXJrZXIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgbWFya2Vyc1ttYXJrZXJzLmxlbmd0aCAtIDFdLnByb2JsZW1zLnB1c2gobmV3IFByb2JsZW0odGhpcy5sb2NhdG9yTWFwLCBlbGVtZW50IGFzIGFueSkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcmtlcnNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb3VudCBiYWRnZVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBXZWJFbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY291bnQgYmFkZ2VcbiAgICAgKi9cbiAgICBnZXRDb3VudEJhZGdlICgpOiBQcm9taXNlPFdlYmRyaXZlcklPLkVsZW1lbnQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQ291bnQkXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1hcmtlciBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBNYXJrZXJMb2NhdG9ycz4ge31cbi8qKlxuICogUGFnZSBvYmplY3QgZm9yIG1hcmtlciBpbiBwcm9ibGVtcyB2aWV3XG4gKlxuICogQGNhdGVnb3J5IEJvdHRvbUJhclxuICovXG5AUGFnZURlY29yYXRvcihNYXJrZXJMb2NhdG9ycylcbmV4cG9ydCBjbGFzcyBNYXJrZXIgZXh0ZW5kcyBFbGVtZW50V2l0aENvbnRleHRNZW51PHR5cGVvZiBNYXJrZXJMb2NhdG9ycz4ge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnTWFya2VyJyBhcyBjb25zdFxuICAgIHB1YmxpYyBwcm9ibGVtczogUHJvYmxlbVtdID0gW11cblxuICAgIGNvbnN0cnVjdG9yIChcbiAgICAgICAgbG9jYXRvcnM6IFZTQ29kZUxvY2F0b3JNYXAsXG4gICAgICAgIGVsZW1lbnQ6IENoYWluYWJsZVByb21pc2VFbGVtZW50PFdlYmRyaXZlcklPLkVsZW1lbnQ+LFxuICAgICAgICBwdWJsaWMgdmlldzogUHJvYmxlbXNWaWV3XG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGxvY2F0b3JzLCBlbGVtZW50LCB2aWV3LmVsZW0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0eXBlIG9mIHRoZSBtYXJrZXJcbiAgICAgKiBQb3NzaWJsZSB0eXBlcyBhcmU6IEZpbGUsIEVycm9yLCBXYXJuaW5nXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYSBNYXJrZXJUeXBlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHlwZSAoKTogUHJvbWlzZTxNYXJrZXJUeXBlPiB7XG4gICAgICAgIGNvbnN0IHR3aXN0ID0gYXdhaXQgdGhpcy5lbGVtLiQodGhpcy5sb2NhdG9yTWFwLlByb2JsZW1zVmlldy5tYXJrZXJUd2lzdGllIGFzIHN0cmluZylcbiAgICAgICAgaWYgKChhd2FpdCB0d2lzdC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpLmluZGV4T2YoJ2NvbGxhcHNpYmxlJykgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hcmtlclR5cGUuRmlsZVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCB0aGlzLmdldFRleHQoKVxuICAgICAgICBpZiAodGV4dC5zdGFydHNXaXRoKCdFcnJvcicpKSB7XG4gICAgICAgICAgICByZXR1cm4gTWFya2VyVHlwZS5FcnJvclxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hcmtlclR5cGUuV2FybmluZ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgZmlsZSB0aGF0IGhhcyBwcm9ibGVtc1xuICAgICAqIEByZXR1cm5zIG5hbWUgb2YgZmlsZSBjb250YWluaW5nIHByb2JsZW1zXG4gICAgICovXG4gICAgZ2V0RmlsZU5hbWUgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVOYW1lJC5nZXRUZXh0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGVycm9yIGNvdW50IG9mIHRoZSBmaWxlIHRoYXQgaGFzIHByb2JsZW1zXG4gICAgICogQHJldHVybnMgZXJyb3IgY291bnQgb2YgZmlsZSBjb250YWluaW5nIHByb2JsZW1zXG4gICAgICovXG4gICAgZ2V0UHJvYmxlbUNvdW50ICgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9ibGVtQ291bnQkLmdldFRleHQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZnVsbCB0ZXh0IG9mIHRoZSBtYXJrZXJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBtYXJrZXIgdGV4dFxuICAgICAqL1xuICAgIGFzeW5jIGdldFRleHQgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW0uZ2V0QXR0cmlidXRlKHRoaXMubG9jYXRvcnMucm93TGFiZWwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kL0NvbGxhcHNlIHRoZSBtYXJrZXIgaWYgcG9zc2libGVcbiAgICAgKiBAcGFyYW0gZXhwYW5kIHRydWUgdG8gZXhwYW5kLCBmYWxzZSB0byBjb2xsYXBzZVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGV4cGFuZC9jb2xsYXBzZSB0d2lzdGllIGlzIGNsaWNrZWRcbiAgICAgKi9cbiAgICBhc3luYyB0b2dnbGVFeHBhbmQgKGV4cGFuZDogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBrbGFzcyA9IGF3YWl0IHRoaXMubWFya2VyVHdpc3RpZSQuZ2V0QXR0cmlidXRlKCdjbGFzcycpXG4gICAgICAgIGlmICgoa2xhc3MuaW5kZXhPZignY29sbGFwc2VkJykgPiAtMSkgPT09IGV4cGFuZCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5lbGVtLmNsaWNrKClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9ibGVtIGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8dHlwZW9mIE1hcmtlckxvY2F0b3JzPiB7fVxuLyoqXG4gKiBQYWdlIG9iamVjdCBmb3IgbWFya2VyIGluIHByb2JsZW1zIHZpZXdcbiAqXG4gKiBAY2F0ZWdvcnkgQm90dG9tQmFyXG4gKi9cbkBQYWdlRGVjb3JhdG9yKE1hcmtlckxvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIFByb2JsZW0gZXh0ZW5kcyBFbGVtZW50V2l0aENvbnRleHRNZW51PHR5cGVvZiBNYXJrZXJMb2NhdG9ycz4ge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnTWFya2VyJyBhcyBjb25zdFxuXG4gICAgLyoqXG4gICAgICogUHJvYmxlbSBkZXRhaWxzXG4gICAgICogQHJldHVybnMgcHJvYmxlbSBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIGdldFRleHQgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXRhaWxzVGV4dCQuZ2V0VGV4dCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBmaWxlIHdoZXJlIHRoZSBwcm9ibGVtIGlzIGxvY2F0ZWRcbiAgICAgKiBAcmV0dXJucyBzb3VyY2UgZmlsZSB0eXBlXG4gICAgICovXG4gICAgZ2V0U291cmNlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGV0YWlsc1NvdXJjZSQuZ2V0VGV4dCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9jYXRpb24gcHJvYmxlbVxuICAgICAqIEByZXR1cm5zIGxvY2F0aW9uIG9mIGVycm9yIGFzIEFycmF5IFtsaW5lLCBjb2x1bW5dXG4gICAgICovXG4gICAgYXN5bmMgZ2V0TG9jYXRpb24gKCkge1xuICAgICAgICBjb25zdCBsb2NhdGlvblRleHQgPSBhd2FpdCB0aGlzLmRldGFpbHNMaW5lJC5nZXRUZXh0KClcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uVGV4dFxuICAgICAgICAgICAgLnNsaWNlKDEsIC0xKVxuICAgICAgICAgICAgLnNwbGl0KCcsJylcbiAgICAgICAgICAgIC5tYXAoKGxvYykgPT4gcGFyc2VJbnQobG9jLnNwbGl0KCcgJykucG9wKCkgYXMgc3RyaW5nLCAxMCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0eXBlIG9mIHRoZSBtYXJrZXJcbiAgICAgKiBQb3NzaWJsZSB0eXBlcyBhcmU6IEZpbGUsIEVycm9yLCBXYXJuaW5nXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYSBNYXJrZXJUeXBlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHlwZSAoKTogUHJvbWlzZTxNYXJrZXJUeXBlPiB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gYXdhaXQgdGhpcy5lbGVtLmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpXG4gICAgICAgIGlmICghbGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXJrZXJUeXBlLlVua25vd25cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFiZWwuc3RhcnRzV2l0aCgnRXJyb3InKSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hcmtlclR5cGUuRXJyb3JcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWFya2VyVHlwZS5XYXJuaW5nXG4gICAgfVxufVxuXG4vKipcbiAqIFBvc3NpYmxlIHR5cGVzIG9mIG1hcmtlcnNcbiAqICAtIEZpbGUgPSBleHBhbmRhYmxlIGl0ZW0gcmVwcmVzZW50aW5nIGEgZmlsZVxuICogIC0gRXJyb3IgPSBhbiBlcnJvciBtYXJrZXJcbiAqICAtIFdhcm5pbmcgPSBhIHdhcm5pbmcgbWFya2VyXG4gKiAgLSBBbnkgPSBhbnkgb2YgdGhlIGFib3ZlXG4gKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZW51bSBNYXJrZXJUeXBlIHtcbiAgICBGaWxlID0gJ2ZpbGUnLFxuICAgIFVua25vd24gPSAndW5rbm93bicsXG4gICAgRXJyb3IgPSAnZXJyb3InLFxuICAgIFdhcm5pbmcgPSAnd2FybmluZycsXG4gICAgQW55ID0gJ2FueSdcbn1cbiJdfQ==