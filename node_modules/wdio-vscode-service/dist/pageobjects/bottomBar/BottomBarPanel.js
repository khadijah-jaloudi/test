var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { DebugConsoleView, OutputView, TerminalView, ProblemsView, EditorView, TitleBar, StatusBar } from '../index.js';
import { BasePage, PageDecorator } from '../utils.js';
import { BottomBarPanel as BottomBarPanelLocators } from '../../locators/1.84.0.js';
/**
 * Page object for the bottom view panel
 *
 * ```ts
 * const bottomBar = workbench.getBottomBar()
 * await bottomBar.toggle(true)
 * ```
 *
 * @category BottomBar
 */
export let BottomBarPanel = class BottomBarPanel extends BasePage {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'BottomBarPanel';
    }
    /**
     * Open/Close the bottom bar panel
     * @param open true to open. false to close
     * @returns Promise resolving when the view visibility is toggled
     */
    async toggle(open) {
        try {
            const tab = await new EditorView(this.locatorMap).getActiveTab();
            await tab?.elem.click();
        }
        catch (err) {
            // ignore and move on
        }
        const height = await this.elem.getSize('height');
        if ((open && height === 0) || (!open && height > 0)) {
            const statusBar = new StatusBar(this.locatorMap);
            await statusBar.problems$.click();
            if (open) {
                await this.wait();
                return;
            }
            /**
             * we might have to click again if we were on a different tab
             * than the problems tab
             */
            if (await this.elem.isDisplayed()) {
                await statusBar.problems$.click();
            }
            await this.elem.waitForDisplayed({ reverse: true });
        }
    }
    /**
     * Open the Problems view in the bottom panel
     * @returns Promise resolving to a ProblemsView object
     */
    async openProblemsView() {
        await this.openTab(this.locators.problemsTab);
        return new ProblemsView(this.locatorMap, this).wait();
    }
    /**
     * Open the Output view in the bottom panel
     * @returns Promise resolving to OutputView object
     */
    async openOutputView() {
        await this.openTab(this.locators.outputTab);
        return new OutputView(this.locatorMap, this).wait();
    }
    /**
     * Open the Debug Console view in the bottom panel
     * @returns Promise resolving to DebugConsoleView object
     */
    async openDebugConsoleView() {
        await this.openTab(this.locators.debugTab);
        return new DebugConsoleView(this.locatorMap, this).wait();
    }
    /**
     * Open the Terminal view in the bottom panel
     * @returns Promise resolving to TerminalView object
     */
    async openTerminalView() {
        await this.openTab(this.locators.terminalTab);
        return new TerminalView(this.locatorMap, this).wait();
    }
    /**
     * Maximize the the bottom panel if not maximized
     * @returns Promise resolving when the maximize button is pressed
     */
    async maximize() {
        await this.resize(this.locators.maximize);
    }
    /**
     * Restore the the bottom panel if maximized
     * @returns Promise resolving when the restore button is pressed
     */
    async restore() {
        await this.resize(this.locators.restore);
    }
    async openTab(title) {
        await this.toggle(true);
        const tabContainer = await this.tabContainer$;
        try {
            const tabs = await tabContainer.$$(this.locators.tab(title));
            if (tabs.length > 0) {
                await tabs[0].click();
            }
            else {
                const label = await tabContainer.$(`.//a[starts-with(@aria-label, '${title}')]`);
                await label.click();
            }
        }
        catch (err) {
            await new TitleBar(this.locatorMap).select('View', title);
        }
    }
    async resize(label) {
        await this.toggle(true);
        let action;
        try {
            action = await this.elem
                .$(this.locators.globalActions)
                .$(this.locators.action(label));
        }
        catch (err) {
            // the panel is already maximized
        }
        if (action) {
            await action.click();
        }
    }
};
BottomBarPanel = __decorate([
    PageDecorator(BottomBarPanelLocators)
], BottomBarPanel);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQm90dG9tQmFyUGFuZWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcGFnZW9iamVjdHMvYm90dG9tQmFyL0JvdHRvbUJhclBhbmVsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFDSCxnQkFBZ0IsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUM5RSxTQUFTLEVBQ1osTUFBTSxhQUFhLENBQUE7QUFDcEIsT0FBTyxFQUFFLFFBQVEsRUFBRSxhQUFhLEVBQWtCLE1BQU0sYUFBYSxDQUFBO0FBQ3JFLE9BQU8sRUFBRSxjQUFjLElBQUksc0JBQXNCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQTtBQUduRjs7Ozs7Ozs7O0dBU0c7QUFFSSxXQUFNLGNBQWMsR0FBcEIsTUFBTSxjQUFlLFNBQVEsUUFBdUM7SUFBcEU7O1FBQ0g7O1dBRUc7UUFDSSxlQUFVLEdBQUcsZ0JBQXlCLENBQUE7SUF1SGpELENBQUM7SUFySEc7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxNQUFNLENBQUUsSUFBYTtRQUN2QixJQUFJO1lBQ0EsTUFBTSxHQUFHLEdBQUcsTUFBTSxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsWUFBWSxFQUFFLENBQUE7WUFDaEUsTUFBTSxHQUFHLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFBO1NBQzFCO1FBQUMsT0FBTyxHQUFHLEVBQUU7WUFDVixxQkFBcUI7U0FDeEI7UUFDRCxNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFBO1FBRWhELElBQUksQ0FBQyxJQUFJLElBQUksTUFBTSxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQyxFQUFFO1lBQ2pELE1BQU0sU0FBUyxHQUFHLElBQUksU0FB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Q1YsTUFBTSxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQTtTQUM1RDtJQUNMLENBQUM7SUFFTyxLQUFLLENBQUMsTUFBTSxDQUFFLEtBQWE7UUFDL0IsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFBO1FBQ3ZCLElBQUksTUFBNEIsQ0FBQTtRQUNoQyxJQUFJO1lBQ0EsTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLElBQUk7aUJBQ25CLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQztpQkFDOUIsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUE7U0FDdEM7UUFBQyxPQUFPLEdBQUcsRUFBRTtZQUNWLGlDQUFpQztTQUNwQztRQUNELElBQUksTUFBTSxFQUFFO1lBQ1IsTUFBTSxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUE7U0FDdkI7SUFDTCxDQUFDO0NBQ0osQ0FBQTtBQTNIWSxjQUFjO0lBRDFCLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBQztHQUN6QixjQUFjLENBMkgxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgRGVidWdDb25zb2xlVmlldywgT3V0cHV0VmlldywgVGVybWluYWxWaWV3LCBQcm9ibGVtc1ZpZXcsIEVkaXRvclZpZXcsIFRpdGxlQmFyLFxuICAgIFN0YXR1c0JhclxufSBmcm9tICcuLi9pbmRleC5qcydcbmltcG9ydCB7IEJhc2VQYWdlLCBQYWdlRGVjb3JhdG9yLCBJUGFnZURlY29yYXRvciB9IGZyb20gJy4uL3V0aWxzLmpzJ1xuaW1wb3J0IHsgQm90dG9tQmFyUGFuZWwgYXMgQm90dG9tQmFyUGFuZWxMb2NhdG9ycyB9IGZyb20gJy4uLy4uL2xvY2F0b3JzLzEuODQuMC5qcydcblxuZXhwb3J0IGludGVyZmFjZSBCb3R0b21CYXJQYW5lbCBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBCb3R0b21CYXJQYW5lbExvY2F0b3JzPiB7fVxuLyoqXG4gKiBQYWdlIG9iamVjdCBmb3IgdGhlIGJvdHRvbSB2aWV3IHBhbmVsXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IGJvdHRvbUJhciA9IHdvcmtiZW5jaC5nZXRCb3R0b21CYXIoKVxuICogYXdhaXQgYm90dG9tQmFyLnRvZ2dsZSh0cnVlKVxuICogYGBgXG4gKlxuICogQGNhdGVnb3J5IEJvdHRvbUJhclxuICovXG5AUGFnZURlY29yYXRvcihCb3R0b21CYXJQYW5lbExvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIEJvdHRvbUJhclBhbmVsIGV4dGVuZHMgQmFzZVBhZ2U8dHlwZW9mIEJvdHRvbUJhclBhbmVsTG9jYXRvcnM+IHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBsb2NhdG9yS2V5ID0gJ0JvdHRvbUJhclBhbmVsJyBhcyBjb25zdFxuXG4gICAgLyoqXG4gICAgICogT3Blbi9DbG9zZSB0aGUgYm90dG9tIGJhciBwYW5lbFxuICAgICAqIEBwYXJhbSBvcGVuIHRydWUgdG8gb3Blbi4gZmFsc2UgdG8gY2xvc2VcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSB2aWV3IHZpc2liaWxpdHkgaXMgdG9nZ2xlZFxuICAgICAqL1xuICAgIGFzeW5jIHRvZ2dsZSAob3BlbjogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdGFiID0gYXdhaXQgbmV3IEVkaXRvclZpZXcodGhpcy5sb2NhdG9yTWFwKS5nZXRBY3RpdmVUYWIoKVxuICAgICAgICAgICAgYXdhaXQgdGFiPy5lbGVtLmNsaWNrKClcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgYW5kIG1vdmUgb25cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWlnaHQgPSBhd2FpdCB0aGlzLmVsZW0uZ2V0U2l6ZSgnaGVpZ2h0JylcblxuICAgICAgICBpZiAoKG9wZW4gJiYgaGVpZ2h0ID09PSAwKSB8fCAoIW9wZW4gJiYgaGVpZ2h0ID4gMCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c0JhciA9IG5ldyBTdGF0dXNCYXIodGhpcy5sb2NhdG9yTWFwKVxuICAgICAgICAgICAgYXdhaXQgc3RhdHVzQmFyLnByb2JsZW1zJC5jbGljaygpXG5cbiAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy53YWl0KClcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiB3ZSBtaWdodCBoYXZlIHRvIGNsaWNrIGFnYWluIGlmIHdlIHdlcmUgb24gYSBkaWZmZXJlbnQgdGFiXG4gICAgICAgICAgICAgKiB0aGFuIHRoZSBwcm9ibGVtcyB0YWJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGF3YWl0IHRoaXMuZWxlbS5pc0Rpc3BsYXllZCgpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3RhdHVzQmFyLnByb2JsZW1zJC5jbGljaygpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZWxlbS53YWl0Rm9yRGlzcGxheWVkKHsgcmV2ZXJzZTogdHJ1ZSB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbiB0aGUgUHJvYmxlbXMgdmlldyBpbiB0aGUgYm90dG9tIHBhbmVsXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYSBQcm9ibGVtc1ZpZXcgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgb3BlblByb2JsZW1zVmlldyAoKTogUHJvbWlzZTxQcm9ibGVtc1ZpZXc+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5vcGVuVGFiKHRoaXMubG9jYXRvcnMucHJvYmxlbXNUYWIpXG4gICAgICAgIHJldHVybiBuZXcgUHJvYmxlbXNWaWV3KHRoaXMubG9jYXRvck1hcCwgdGhpcykud2FpdCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbiB0aGUgT3V0cHV0IHZpZXcgaW4gdGhlIGJvdHRvbSBwYW5lbFxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIE91dHB1dFZpZXcgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgb3Blbk91dHB1dFZpZXcgKCk6IFByb21pc2U8T3V0cHV0Vmlldz4ge1xuICAgICAgICBhd2FpdCB0aGlzLm9wZW5UYWIodGhpcy5sb2NhdG9ycy5vdXRwdXRUYWIpXG4gICAgICAgIHJldHVybiBuZXcgT3V0cHV0Vmlldyh0aGlzLmxvY2F0b3JNYXAsIHRoaXMpLndhaXQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIERlYnVnIENvbnNvbGUgdmlldyBpbiB0aGUgYm90dG9tIHBhbmVsXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gRGVidWdDb25zb2xlVmlldyBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBvcGVuRGVidWdDb25zb2xlVmlldyAoKTogUHJvbWlzZTxEZWJ1Z0NvbnNvbGVWaWV3PiB7XG4gICAgICAgIGF3YWl0IHRoaXMub3BlblRhYih0aGlzLmxvY2F0b3JzLmRlYnVnVGFiKVxuICAgICAgICByZXR1cm4gbmV3IERlYnVnQ29uc29sZVZpZXcodGhpcy5sb2NhdG9yTWFwLCB0aGlzKS53YWl0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoZSBUZXJtaW5hbCB2aWV3IGluIHRoZSBib3R0b20gcGFuZWxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBUZXJtaW5hbFZpZXcgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgb3BlblRlcm1pbmFsVmlldyAoKTogUHJvbWlzZTxUZXJtaW5hbFZpZXc+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5vcGVuVGFiKHRoaXMubG9jYXRvcnMudGVybWluYWxUYWIpXG4gICAgICAgIHJldHVybiBuZXcgVGVybWluYWxWaWV3KHRoaXMubG9jYXRvck1hcCwgdGhpcykud2FpdCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWF4aW1pemUgdGhlIHRoZSBib3R0b20gcGFuZWwgaWYgbm90IG1heGltaXplZFxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIG1heGltaXplIGJ1dHRvbiBpcyBwcmVzc2VkXG4gICAgICovXG4gICAgYXN5bmMgbWF4aW1pemUgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCB0aGlzLnJlc2l6ZSh0aGlzLmxvY2F0b3JzLm1heGltaXplKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgdGhlIHRoZSBib3R0b20gcGFuZWwgaWYgbWF4aW1pemVkXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgcmVzdG9yZSBidXR0b24gaXMgcHJlc3NlZFxuICAgICAqL1xuICAgIGFzeW5jIHJlc3RvcmUgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCB0aGlzLnJlc2l6ZSh0aGlzLmxvY2F0b3JzLnJlc3RvcmUpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBvcGVuVGFiICh0aXRsZTogc3RyaW5nKSB7XG4gICAgICAgIGF3YWl0IHRoaXMudG9nZ2xlKHRydWUpXG4gICAgICAgIGNvbnN0IHRhYkNvbnRhaW5lciA9IGF3YWl0IHRoaXMudGFiQ29udGFpbmVyJFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdGFicyA9IGF3YWl0IHRhYkNvbnRhaW5lci4kJCh0aGlzLmxvY2F0b3JzLnRhYih0aXRsZSkpXG4gICAgICAgICAgICBpZiAodGFicy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGFic1swXS5jbGljaygpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gYXdhaXQgdGFiQ29udGFpbmVyLiQoYC4vL2Fbc3RhcnRzLXdpdGgoQGFyaWEtbGFiZWwsICcke3RpdGxlfScpXWApXG4gICAgICAgICAgICAgICAgYXdhaXQgbGFiZWwuY2xpY2soKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBUaXRsZUJhcih0aGlzLmxvY2F0b3JNYXApLnNlbGVjdCgnVmlldycsIHRpdGxlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyByZXNpemUgKGxhYmVsOiBzdHJpbmcpIHtcbiAgICAgICAgYXdhaXQgdGhpcy50b2dnbGUodHJ1ZSlcbiAgICAgICAgbGV0IGFjdGlvbiE6IFdlYmRyaXZlcklPLkVsZW1lbnRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFjdGlvbiA9IGF3YWl0IHRoaXMuZWxlbVxuICAgICAgICAgICAgICAgIC4kKHRoaXMubG9jYXRvcnMuZ2xvYmFsQWN0aW9ucylcbiAgICAgICAgICAgICAgICAuJCh0aGlzLmxvY2F0b3JzLmFjdGlvbihsYWJlbCkpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gdGhlIHBhbmVsIGlzIGFscmVhZHkgbWF4aW1pemVkXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgYXdhaXQgYWN0aW9uLmNsaWNrKClcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==