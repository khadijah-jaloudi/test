var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Key } from 'webdriverio';
import { SideBarView } from '../SideBarView.js';
import { ContextMenu } from '../../index.js';
import { ElementWithContextMenu, PageDecorator, BasePage } from '../../utils.js';
import { ScmView as ScmViewLocators } from '../../../locators/1.73.0.js';
import { CMD_KEY } from '../../../constants.js';
/**
 * Page object representing the Source Control view
 *
 * @category Sidebar
 */
export let ScmView = class ScmView extends SideBarView {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
    /**
     * Get SCM provider (repository) by title
     * @param title name of the repository
     * @returns promise resolving to ScmProvider object
     */
    async getProvider(title) {
        const providers = await this.getProviders();
        if (!title || providers.length === 1) {
            return providers[0];
        }
        const names = await Promise.all(providers.map(async (item) => item.getTitle()));
        const index = names.findIndex((name) => name === title);
        return index > -1 ? providers[index] : undefined;
    }
    /**
     * Get all SCM providers
     * @returns promise resolving to ScmProvider array
     */
    async getProviders() {
        const headers = await this.providerHeader$$;
        const sections = await Promise.all(headers.map(async (header) => header.$(this.locators.providerRelative)));
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        return Promise.all(sections.map((section) => new ScmProvider(this.locatorMap, section, this)));
    }
    /**
     * Initialize repository in the current folder if no SCM provider is found
     * @returns true if the action was completed succesfully, false if a provider already exists
     */
    async initializeRepository() {
        const buttons = await this.initButton$$;
        if (buttons.length > 0) {
            await buttons[0].click();
            return true;
        }
        return false;
    }
};
ScmView = __decorate([
    PageDecorator(ScmViewLocators)
], ScmView);
/**
 * Page object representing a repository in the source control view
 * Maps roughly to a view section of the source control view
 *
 * @category Sidebar
 */
export let ScmProvider = class ScmProvider extends BasePage {
    constructor(locators, element, view) {
        super(locators, element, view.elem);
        this.view = view;
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
    /**
     * Get title of the scm provider
     */
    async getTitle() {
        return this.providerTitle$.getAttribute('innerHTML');
    }
    /**
     * Get type of the scm provider (e.g. Git)
     */
    async getType() {
        return this.providerType$.getAttribute('innerHTML');
    }
    /**
     * Find an action button for the SCM provider by title and click it. (e.g 'Commit')
     * @param title Title of the action button to click
     * @returns true if the given action could be performed, false if the button doesn't exist
     */
    async takeAction(title) {
        const header = await this.providerHeader$;
        let actions = [];
        if ((await header.getAttribute('class')).indexOf('hidden') > -1) {
            actions = (await this.view.getTitlePart().getActions()).map((action) => action.elem);
        }
        else {
            await this.elem.moveTo();
            actions = await header.$$(this.locators.action);
        }
        const names = await Promise.all(actions.map((action) => action.getAttribute('title')));
        const index = names.findIndex((item) => item === title);
        if (index > -1) {
            await actions[index].click();
            return true;
        }
        return false;
    }
    /**
     * Open a context menu using the 'More Actions...' button
     * @returns Promise resolving to a ContextMenu object
     */
    async openMoreActions() {
        const header = await this.providerHeader$;
        if ((await header.getAttribute('class')).indexOf('hidden') > -1) {
            return new MoreAction(this.locatorMap, this.view).openContextMenu();
        }
        await this.elem.moveTo();
        return new MoreAction(this.locatorMap, this).openContextMenu();
    }
    /**
     * Fill in the message field and send ctrl/cmd + enter to commit the changes
     * @param message the commit message to use
     * @returns promise resolving once the keypresses are sent
     */
    async commitChanges(message) {
        const input = await this.inputField$;
        await input.clearValue();
        await input.addValue(message);
        await browser.action('key')
            .down(CMD_KEY).down(Key.Enter)
            .up(CMD_KEY).up(Key.Enter)
            .perform();
    }
    /**
     * Get page objects for all tree items representing individual changes
     * @param staged when true, finds staged changes otherwise finds unstaged changes
     * @returns promise resolving to ScmChange object array
     */
    async getChanges(staged = false) {
        const changes = await this.getChangeCount(staged);
        const label = staged ? 'STAGED CHANGES' : 'CHANGES';
        let elements = [];
        if (changes > 0) {
            let i = -1;
            elements = await this.changeItem$$;
            for (const [index, item] of elements.entries()) {
                const name = await item.$(this.locators.changeName);
                if (await name.getText() === label) {
                    i = index + 1;
                    break;
                }
            }
            if (i < 0) {
                return [];
            }
            elements = elements.slice(i, i + changes);
        }
        return Promise.all(elements.map((element) => (new ScmChange(this.locatorMap, element, this).wait())));
    }
    /**
     * Get the number of changes for a given section
     * @param staged when true, counts the staged changes, unstaged otherwise
     * @returns promise resolving to number of changes in the given subsection
     */
    async getChangeCount(staged = false) {
        const rows = staged
            ? await this.stagedChanges$$
            : await this.changes$$;
        if (rows.length < 1) {
            return 0;
        }
        const count = await rows[0].$(this.locators.changeCount);
        return +await count.getText();
    }
};
ScmProvider = __decorate([
    PageDecorator(ScmViewLocators)
], ScmProvider);
/**
 * Page object representing a SCM change tree item
 *
 * @category Sidebar
 */
export let ScmChange = class ScmChange extends ElementWithContextMenu {
    constructor(locators, row, provider) {
        super(locators, row, provider.elem);
        this.provider = provider;
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
    /**
     * Get label as a string
     */
    async getLabel() {
        return this.changeLabel$.getText();
    }
    /**
     * Get description as a string
     */
    async getDescription() {
        const desc = await this.changeDesc$$;
        if (desc.length < 1) {
            return '';
        }
        return desc[0].getText();
    }
    /**
     * Get the status string (e.g. 'Modified')
     */
    async getStatus() {
        const res = await this.resource$;
        const status = await res.getAttribute('data-tooltip');
        if (status && status.length > 0) {
            return status;
        }
        return 'folder';
    }
    /**
     * Find if the item is expanded
     * @returns promise resolving to true if change is expanded, to false otherwise
     */
    async isExpanded() {
        const twisties = await this.expand$$;
        if (twisties.length < 1) {
            return true;
        }
        return (await twisties[0].getAttribute('class')).indexOf('collapsed') < 0;
    }
    /**
     * Expand or collapse a change item if possible, only works for folders in hierarchical view mode
     * @param expand true to expand the item, false to collapse
     * @returns promise resolving to true if the item changed state, to false otherwise
     */
    async toggleExpand(expand) {
        if (await this.isExpanded() !== expand) {
            await this.elem.click();
            return true;
        }
        return false;
    }
    /**
     * Find and click an action button available to a given change tree item
     * @param title title of the action button (e.g 'Stage Changes')
     * @returns promise resolving to true if the action was performed successfully,
     * false if the given button does not exist
     */
    async takeAction(title) {
        await this.elem.moveTo();
        const actions = await this.action$$;
        const names = await Promise.all(actions.map((action) => action.getAttribute('title')));
        const index = names.findIndex((item) => item === title);
        if (index > -1) {
            await actions[index].click();
            return true;
        }
        return false;
    }
};
ScmChange = __decorate([
    PageDecorator(ScmViewLocators)
], ScmChange);
/**
 * More Action
 *
 * @category Sidebar
 */
export let MoreAction = class MoreAction extends ElementWithContextMenu {
    constructor(locators, scm) {
        super(locators, locators.ScmView.more, scm.elem);
        this.scm = scm;
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
    async openContextMenu() {
        await this.elem.click();
        const shadowRootHost = await this.scm.elem.$$('shadow-root-host');
        await browser.keys('Escape');
        if (shadowRootHost.length > 0) {
            if (await this.elem.getAttribute('aria-expanded') !== 'true') {
                await this.elem.click();
            }
            const shadowRoot = $(await browser.execute('return arguments[0].shadowRoot', shadowRootHost[0]));
            return new ContextMenu(this.locatorMap, shadowRoot).wait();
        }
        return super.openContextMenu();
    }
};
MoreAction = __decorate([
    PageDecorator(ScmViewLocators)
], MoreAction);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2NtVmlldy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9wYWdlb2JqZWN0cy9zaWRlYmFyL3NjbS9TY21WaWV3LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFBRSxHQUFHLEVBQTJCLE1BQU0sYUFBYSxDQUFBO0FBRTFELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQTtBQUMvQyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUE7QUFDNUMsT0FBTyxFQUNILHNCQUFzQixFQUFvQixhQUFhLEVBQWtCLFFBQVEsRUFDcEYsTUFBTSxnQkFBZ0IsQ0FBQTtBQUN2QixPQUFPLEVBQUUsT0FBTyxJQUFJLGVBQWUsRUFBRSxNQUFNLDZCQUE2QixDQUFBO0FBQ3hFLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQTtBQUcvQzs7OztHQUlHO0FBRUksV0FBTSxPQUFPLEdBQWIsTUFBTSxPQUFRLFNBQVEsV0FBbUM7SUFBekQ7O1FBQ0g7O1dBRUc7UUFDSSxlQUFVLEdBQUcsU0FBa0IsQ0FBQTtJQXlDMUMsQ0FBQztJQXZDRzs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLFdBQVcsQ0FBRSxLQUFjO1FBQzdCLE1BQU0sU0FBUyxHQUFHLE1BQU0sSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFBO1FBQzNDLElBQUksQ0FBQyxLQUFLLElBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDbEMsT0FBTyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUE7U0FDdEI7UUFDRCxNQUFNLEtBQUssR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFBO1FBQy9FLE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxT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QUFrQixDQUFBO0lBT3RDLENBQUM7SUFFRCxLQUFLLENBQUMsZUFBZTtRQUNqQixNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUE7UUFDdkIsTUFBTSxjQUFjLEdBQUcsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsa0JBQWtCLENBQUMsQ0FBQTtRQUNqRSxNQUFNLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUE7UUFFNUIsSUFBSSxjQUFjLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUMzQixJQUFJLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsZUFBZSxDQUFDLEtBQUssTUFBTSxFQUFFO2dCQUMxRCxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUE7YUFDMUI7WUFDRCxNQUFNLFVBQVUsR0FBRyxDQUFDLENBQUMsTUFBTSxPQUFPLENBQUMsT0FBTyxDQUFDLGdDQUFnQyxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7WUFDaEcsT0FBTyxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFBO1NBQzdEO1FBQ0QsT0FBTyxLQUFLLENBQUMsZUFBZSxFQUFFLENBQUE7SUFDbEMsQ0FBQztDQUNKLENBQUE7QUEzQlksVUFBVTtJQUR0QixhQUFhLENBQUMsZUFBZSxDQUFDO0dBQ2xCLFVBQVUsQ0EyQnRCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgS2V5LCBDaGFpbmFibGVQcm9taXNlRWxlbWVudCB9IGZyb20gJ3dlYmRyaXZlcmlvJ1xuXG5pbXBvcnQgeyBTaWRlQmFyVmlldyB9IGZyb20gJy4uL1NpZGVCYXJWaWV3LmpzJ1xuaW1wb3J0IHsgQ29udGV4dE1lbnUgfSBmcm9tICcuLi8uLi9pbmRleC5qcydcbmltcG9ydCB7XG4gICAgRWxlbWVudFdpdGhDb250ZXh0TWVudSwgVlNDb2RlTG9jYXRvck1hcCwgUGFnZURlY29yYXRvciwgSVBhZ2VEZWNvcmF0b3IsIEJhc2VQYWdlXG59IGZyb20gJy4uLy4uL3V0aWxzLmpzJ1xuaW1wb3J0IHsgU2NtVmlldyBhcyBTY21WaWV3TG9jYXRvcnMgfSBmcm9tICcuLi8uLi8uLi9sb2NhdG9ycy8xLjczLjAuanMnXG5pbXBvcnQgeyBDTURfS0VZIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFNjbVZpZXcgZXh0ZW5kcyBJUGFnZURlY29yYXRvcjx0eXBlb2YgU2NtVmlld0xvY2F0b3JzPiB7IH1cbi8qKlxuICogUGFnZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBTb3VyY2UgQ29udHJvbCB2aWV3XG4gKlxuICogQGNhdGVnb3J5IFNpZGViYXJcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoU2NtVmlld0xvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIFNjbVZpZXcgZXh0ZW5kcyBTaWRlQmFyVmlldzx0eXBlb2YgU2NtVmlld0xvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdTY21WaWV3JyBhcyBjb25zdFxuXG4gICAgLyoqXG4gICAgICogR2V0IFNDTSBwcm92aWRlciAocmVwb3NpdG9yeSkgYnkgdGl0bGVcbiAgICAgKiBAcGFyYW0gdGl0bGUgbmFtZSBvZiB0aGUgcmVwb3NpdG9yeVxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIFNjbVByb3ZpZGVyIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIGdldFByb3ZpZGVyICh0aXRsZT86IHN0cmluZyk6IFByb21pc2U8U2NtUHJvdmlkZXIgfCB1bmRlZmluZWQ+IHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJzID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcnMoKVxuICAgICAgICBpZiAoIXRpdGxlIHx8IHByb3ZpZGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlcnNbMF1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lcyA9IGF3YWl0IFByb21pc2UuYWxsKHByb3ZpZGVycy5tYXAoYXN5bmMgKGl0ZW0pID0+IGl0ZW0uZ2V0VGl0bGUoKSkpXG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZXMuZmluZEluZGV4KChuYW1lKSA9PiBuYW1lID09PSB0aXRsZSlcblxuICAgICAgICByZXR1cm4gaW5kZXggPiAtMSA/IHByb3ZpZGVyc1tpbmRleF0gOiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIFNDTSBwcm92aWRlcnNcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byBTY21Qcm92aWRlciBhcnJheVxuICAgICAqL1xuICAgIGFzeW5jIGdldFByb3ZpZGVycyAoKTogUHJvbWlzZTxTY21Qcm92aWRlcltdPiB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCB0aGlzLnByb3ZpZGVySGVhZGVyJCRcbiAgICAgICAgY29uc3Qgc2VjdGlvbnMgPSBhd2FpdCBQcm9taXNlLmFsbChoZWFkZXJzLm1hcChhc3luYyAoaGVhZGVyKSA9PiBoZWFkZXIuJCh0aGlzLmxvY2F0b3JzLnByb3ZpZGVyUmVsYXRpdmUpKSlcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHNlY3Rpb25zLm1hcCgoc2VjdGlvbikgPT4gbmV3IFNjbVByb3ZpZGVyKHRoaXMubG9jYXRvck1hcCwgc2VjdGlvbiBhcyBhbnksIHRoaXMpKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHJlcG9zaXRvcnkgaW4gdGhlIGN1cnJlbnQgZm9sZGVyIGlmIG5vIFNDTSBwcm92aWRlciBpcyBmb3VuZFxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGFjdGlvbiB3YXMgY29tcGxldGVkIHN1Y2Nlc2Z1bGx5LCBmYWxzZSBpZiBhIHByb3ZpZGVyIGFscmVhZHkgZXhpc3RzXG4gICAgICovXG4gICAgYXN5bmMgaW5pdGlhbGl6ZVJlcG9zaXRvcnkgKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBjb25zdCBidXR0b25zID0gYXdhaXQgdGhpcy5pbml0QnV0dG9uJCRcbiAgICAgICAgaWYgKGJ1dHRvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgYnV0dG9uc1swXS5jbGljaygpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY21Qcm92aWRlciBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBTY21WaWV3TG9jYXRvcnM+IHsgfVxuLyoqXG4gKiBQYWdlIG9iamVjdCByZXByZXNlbnRpbmcgYSByZXBvc2l0b3J5IGluIHRoZSBzb3VyY2UgY29udHJvbCB2aWV3XG4gKiBNYXBzIHJvdWdobHkgdG8gYSB2aWV3IHNlY3Rpb24gb2YgdGhlIHNvdXJjZSBjb250cm9sIHZpZXdcbiAqXG4gKiBAY2F0ZWdvcnkgU2lkZWJhclxuICovXG5AUGFnZURlY29yYXRvcihTY21WaWV3TG9jYXRvcnMpXG5leHBvcnQgY2xhc3MgU2NtUHJvdmlkZXIgZXh0ZW5kcyBCYXNlUGFnZTx0eXBlb2YgU2NtVmlld0xvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdTY21WaWV3JyBhcyBjb25zdFxuICAgIGNvbnN0cnVjdG9yIChcbiAgICAgICAgbG9jYXRvcnM6IFZTQ29kZUxvY2F0b3JNYXAsXG4gICAgICAgIGVsZW1lbnQ6IENoYWluYWJsZVByb21pc2VFbGVtZW50PFdlYmRyaXZlcklPLkVsZW1lbnQ+LFxuICAgICAgICBwdWJsaWMgdmlldzogU2NtVmlld1xuICAgICkge1xuICAgICAgICBzdXBlcihsb2NhdG9ycywgZWxlbWVudCwgdmlldy5lbGVtKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aXRsZSBvZiB0aGUgc2NtIHByb3ZpZGVyXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VGl0bGUgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyVGl0bGUkLmdldEF0dHJpYnV0ZSgnaW5uZXJIVE1MJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdHlwZSBvZiB0aGUgc2NtIHByb3ZpZGVyIChlLmcuIEdpdClcbiAgICAgKi9cbiAgICBhc3luYyBnZXRUeXBlICgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlclR5cGUkLmdldEF0dHJpYnV0ZSgnaW5uZXJIVE1MJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuIGFjdGlvbiBidXR0b24gZm9yIHRoZSBTQ00gcHJvdmlkZXIgYnkgdGl0bGUgYW5kIGNsaWNrIGl0LiAoZS5nICdDb21taXQnKVxuICAgICAqIEBwYXJhbSB0aXRsZSBUaXRsZSBvZiB0aGUgYWN0aW9uIGJ1dHRvbiB0byBjbGlja1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGFjdGlvbiBjb3VsZCBiZSBwZXJmb3JtZWQsIGZhbHNlIGlmIHRoZSBidXR0b24gZG9lc24ndCBleGlzdFxuICAgICAqL1xuICAgIGFzeW5jIHRha2VBY3Rpb24gKHRpdGxlOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gYXdhaXQgdGhpcy5wcm92aWRlckhlYWRlciRcbiAgICAgICAgbGV0IGFjdGlvbnM6IENoYWluYWJsZVByb21pc2VFbGVtZW50PFdlYmRyaXZlcklPLkVsZW1lbnQ+W10gPSBbXVxuICAgICAgICBpZiAoKGF3YWl0IGhlYWRlci5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpLmluZGV4T2YoJ2hpZGRlbicpID4gLTEpIHtcbiAgICAgICAgICAgIGFjdGlvbnMgPSAoYXdhaXQgdGhpcy52aWV3LmdldFRpdGxlUGFydCgpLmdldEFjdGlvbnMoKSkubWFwKChhY3Rpb24pID0+IGFjdGlvbi5lbGVtKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5lbGVtLm1vdmVUbygpXG4gICAgICAgICAgICBhY3Rpb25zID0gYXdhaXQgaGVhZGVyLiQkKHRoaXMubG9jYXRvcnMuYWN0aW9uKSBhcyBhbnkgYXMgQ2hhaW5hYmxlUHJvbWlzZUVsZW1lbnQ8V2ViZHJpdmVySU8uRWxlbWVudD5bXVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoYWN0aW9ucy5tYXAoKGFjdGlvbikgPT4gYWN0aW9uLmdldEF0dHJpYnV0ZSgndGl0bGUnKSkpXG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZXMuZmluZEluZGV4KChpdGVtKSA9PiBpdGVtID09PSB0aXRsZSlcblxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgYXdhaXQgYWN0aW9uc1tpbmRleF0uY2xpY2soKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIGEgY29udGV4dCBtZW51IHVzaW5nIHRoZSAnTW9yZSBBY3Rpb25zLi4uJyBidXR0b25cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhIENvbnRleHRNZW51IG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIG9wZW5Nb3JlQWN0aW9ucyAoKTogUHJvbWlzZTxDb250ZXh0TWVudT4ge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBhd2FpdCB0aGlzLnByb3ZpZGVySGVhZGVyJFxuICAgICAgICBpZiAoKGF3YWl0IGhlYWRlci5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpLmluZGV4T2YoJ2hpZGRlbicpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9yZUFjdGlvbih0aGlzLmxvY2F0b3JNYXAsIHRoaXMudmlldykub3BlbkNvbnRleHRNZW51KClcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmVsZW0ubW92ZVRvKClcbiAgICAgICAgcmV0dXJuIG5ldyBNb3JlQWN0aW9uKHRoaXMubG9jYXRvck1hcCwgdGhpcykub3BlbkNvbnRleHRNZW51KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWxsIGluIHRoZSBtZXNzYWdlIGZpZWxkIGFuZCBzZW5kIGN0cmwvY21kICsgZW50ZXIgdG8gY29tbWl0IHRoZSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgdGhlIGNvbW1pdCBtZXNzYWdlIHRvIHVzZVxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIG9uY2UgdGhlIGtleXByZXNzZXMgYXJlIHNlbnRcbiAgICAgKi9cbiAgICBhc3luYyBjb21taXRDaGFuZ2VzIChtZXNzYWdlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBhd2FpdCB0aGlzLmlucHV0RmllbGQkXG4gICAgICAgIGF3YWl0IGlucHV0LmNsZWFyVmFsdWUoKVxuICAgICAgICBhd2FpdCBpbnB1dC5hZGRWYWx1ZShtZXNzYWdlKVxuICAgICAgICBhd2FpdCBicm93c2VyLmFjdGlvbigna2V5JylcbiAgICAgICAgICAgIC5kb3duKENNRF9LRVkpLmRvd24oS2V5LkVudGVyKVxuICAgICAgICAgICAgLnVwKENNRF9LRVkpLnVwKEtleS5FbnRlcilcbiAgICAgICAgICAgIC5wZXJmb3JtKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcGFnZSBvYmplY3RzIGZvciBhbGwgdHJlZSBpdGVtcyByZXByZXNlbnRpbmcgaW5kaXZpZHVhbCBjaGFuZ2VzXG4gICAgICogQHBhcmFtIHN0YWdlZCB3aGVuIHRydWUsIGZpbmRzIHN0YWdlZCBjaGFuZ2VzIG90aGVyd2lzZSBmaW5kcyB1bnN0YWdlZCBjaGFuZ2VzXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gU2NtQ2hhbmdlIG9iamVjdCBhcnJheVxuICAgICAqL1xuICAgIGFzeW5jIGdldENoYW5nZXMgKHN0YWdlZCA9IGZhbHNlKTogUHJvbWlzZTxTY21DaGFuZ2VbXT4ge1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gYXdhaXQgdGhpcy5nZXRDaGFuZ2VDb3VudChzdGFnZWQpXG4gICAgICAgIGNvbnN0IGxhYmVsID0gc3RhZ2VkID8gJ1NUQUdFRCBDSEFOR0VTJyA6ICdDSEFOR0VTJ1xuXG4gICAgICAgIGxldCBlbGVtZW50czogQ2hhaW5hYmxlUHJvbWlzZUVsZW1lbnQ8V2ViZHJpdmVySU8uRWxlbWVudD5bXSA9IFtdXG4gICAgICAgIGlmIChjaGFuZ2VzID4gMCkge1xuICAgICAgICAgICAgbGV0IGkgPSAtMVxuICAgICAgICAgICAgZWxlbWVudHMgPSBhd2FpdCB0aGlzLmNoYW5nZUl0ZW0kJCBhcyBhbnlcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBpdGVtXSBvZiBlbGVtZW50cy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYXdhaXQgaXRlbS4kKHRoaXMubG9jYXRvcnMuY2hhbmdlTmFtZSlcbiAgICAgICAgICAgICAgICBpZiAoYXdhaXQgbmFtZS5nZXRUZXh0KCkgPT09IGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBpbmRleCArIDFcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnRzID0gZWxlbWVudHMuc2xpY2UoaSwgaSArIGNoYW5nZXMpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgZWxlbWVudHMubWFwKChlbGVtZW50KSA9PiAoXG4gICAgICAgICAgICAgICAgbmV3IFNjbUNoYW5nZSh0aGlzLmxvY2F0b3JNYXAsIGVsZW1lbnQsIHRoaXMpLndhaXQoKVxuICAgICAgICAgICAgKSlcbiAgICAgICAgKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGNoYW5nZXMgZm9yIGEgZ2l2ZW4gc2VjdGlvblxuICAgICAqIEBwYXJhbSBzdGFnZWQgd2hlbiB0cnVlLCBjb3VudHMgdGhlIHN0YWdlZCBjaGFuZ2VzLCB1bnN0YWdlZCBvdGhlcndpc2VcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byBudW1iZXIgb2YgY2hhbmdlcyBpbiB0aGUgZ2l2ZW4gc3Vic2VjdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGdldENoYW5nZUNvdW50IChzdGFnZWQgPSBmYWxzZSk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgICAgIGNvbnN0IHJvd3MgPSBzdGFnZWRcbiAgICAgICAgICAgID8gYXdhaXQgdGhpcy5zdGFnZWRDaGFuZ2VzJCRcbiAgICAgICAgICAgIDogYXdhaXQgdGhpcy5jaGFuZ2VzJCRcblxuICAgICAgICBpZiAocm93cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvdW50ID0gYXdhaXQgcm93c1swXS4kKHRoaXMubG9jYXRvcnMuY2hhbmdlQ291bnQpXG4gICAgICAgIHJldHVybiArYXdhaXQgY291bnQuZ2V0VGV4dCgpXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjbUNoYW5nZSBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBTY21WaWV3TG9jYXRvcnM+IHsgfVxuLyoqXG4gKiBQYWdlIG9iamVjdCByZXByZXNlbnRpbmcgYSBTQ00gY2hhbmdlIHRyZWUgaXRlbVxuICpcbiAqIEBjYXRlZ29yeSBTaWRlYmFyXG4gKi9cbkBQYWdlRGVjb3JhdG9yKFNjbVZpZXdMb2NhdG9ycylcbmV4cG9ydCBjbGFzcyBTY21DaGFuZ2UgZXh0ZW5kcyBFbGVtZW50V2l0aENvbnRleHRNZW51PHR5cGVvZiBTY21WaWV3TG9jYXRvcnM+IHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBsb2NhdG9yS2V5ID0gJ1NjbVZpZXcnIGFzIGNvbnN0XG5cbiAgICBjb25zdHJ1Y3RvciAoXG4gICAgICAgIGxvY2F0b3JzOiBWU0NvZGVMb2NhdG9yTWFwLFxuICAgICAgICByb3c6IENoYWluYWJsZVByb21pc2VFbGVtZW50PFdlYmRyaXZlcklPLkVsZW1lbnQ+LFxuICAgICAgICBwdWJsaWMgcHJvdmlkZXI6IFNjbVByb3ZpZGVyXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGxvY2F0b3JzLCByb3csIHByb3ZpZGVyLmVsZW0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGxhYmVsIGFzIGEgc3RyaW5nXG4gICAgICovXG4gICAgYXN5bmMgZ2V0TGFiZWwgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZUxhYmVsJC5nZXRUZXh0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZGVzY3JpcHRpb24gYXMgYSBzdHJpbmdcbiAgICAgKi9cbiAgICBhc3luYyBnZXREZXNjcmlwdGlvbiAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgZGVzYyA9IGF3YWl0IHRoaXMuY2hhbmdlRGVzYyQkXG4gICAgICAgIGlmIChkZXNjLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXNjWzBdLmdldFRleHQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3RhdHVzIHN0cmluZyAoZS5nLiAnTW9kaWZpZWQnKVxuICAgICAqL1xuICAgIGFzeW5jIGdldFN0YXR1cyAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5yZXNvdXJjZSRcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgcmVzLmdldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwJylcblxuICAgICAgICBpZiAoc3RhdHVzICYmIHN0YXR1cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdHVzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdmb2xkZXInXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBpZiB0aGUgaXRlbSBpcyBleHBhbmRlZFxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIHRydWUgaWYgY2hhbmdlIGlzIGV4cGFuZGVkLCB0byBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhc3luYyBpc0V4cGFuZGVkICgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3QgdHdpc3RpZXMgPSBhd2FpdCB0aGlzLmV4cGFuZCQkXG4gICAgICAgIGlmICh0d2lzdGllcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYXdhaXQgdHdpc3RpZXNbMF0uZ2V0QXR0cmlidXRlKCdjbGFzcycpKS5pbmRleE9mKCdjb2xsYXBzZWQnKSA8IDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmQgb3IgY29sbGFwc2UgYSBjaGFuZ2UgaXRlbSBpZiBwb3NzaWJsZSwgb25seSB3b3JrcyBmb3IgZm9sZGVycyBpbiBoaWVyYXJjaGljYWwgdmlldyBtb2RlXG4gICAgICogQHBhcmFtIGV4cGFuZCB0cnVlIHRvIGV4cGFuZCB0aGUgaXRlbSwgZmFsc2UgdG8gY29sbGFwc2VcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byB0cnVlIGlmIHRoZSBpdGVtIGNoYW5nZWQgc3RhdGUsIHRvIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGFzeW5jIHRvZ2dsZUV4cGFuZCAoZXhwYW5kOiBib29sZWFuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGlmIChhd2FpdCB0aGlzLmlzRXhwYW5kZWQoKSAhPT0gZXhwYW5kKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmVsZW0uY2xpY2soKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuZCBjbGljayBhbiBhY3Rpb24gYnV0dG9uIGF2YWlsYWJsZSB0byBhIGdpdmVuIGNoYW5nZSB0cmVlIGl0ZW1cbiAgICAgKiBAcGFyYW0gdGl0bGUgdGl0bGUgb2YgdGhlIGFjdGlvbiBidXR0b24gKGUuZyAnU3RhZ2UgQ2hhbmdlcycpXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gdHJ1ZSBpZiB0aGUgYWN0aW9uIHdhcyBwZXJmb3JtZWQgc3VjY2Vzc2Z1bGx5LFxuICAgICAqIGZhbHNlIGlmIHRoZSBnaXZlbiBidXR0b24gZG9lcyBub3QgZXhpc3RcbiAgICAgKi9cbiAgICBhc3luYyB0YWtlQWN0aW9uICh0aXRsZTogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGF3YWl0IHRoaXMuZWxlbS5tb3ZlVG8oKVxuICAgICAgICBjb25zdCBhY3Rpb25zID0gYXdhaXQgdGhpcy5hY3Rpb24kJFxuICAgICAgICBjb25zdCBuYW1lcyA9IGF3YWl0IFByb21pc2UuYWxsKGFjdGlvbnMubWFwKChhY3Rpb24pID0+IGFjdGlvbi5nZXRBdHRyaWJ1dGUoJ3RpdGxlJykpKVxuICAgICAgICBjb25zdCBpbmRleCA9IG5hbWVzLmZpbmRJbmRleCgoaXRlbSkgPT4gaXRlbSA9PT0gdGl0bGUpXG5cbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGF3YWl0IGFjdGlvbnNbaW5kZXhdLmNsaWNrKClcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vcmVBY3Rpb24gZXh0ZW5kcyBJUGFnZURlY29yYXRvcjx0eXBlb2YgU2NtVmlld0xvY2F0b3JzPiB7IH1cbi8qKlxuICogTW9yZSBBY3Rpb25cbiAqXG4gKiBAY2F0ZWdvcnkgU2lkZWJhclxuICovXG5AUGFnZURlY29yYXRvcihTY21WaWV3TG9jYXRvcnMpXG5leHBvcnQgY2xhc3MgTW9yZUFjdGlvbiBleHRlbmRzIEVsZW1lbnRXaXRoQ29udGV4dE1lbnU8dHlwZW9mIFNjbVZpZXdMb2NhdG9ycz4ge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnU2NtVmlldycgYXMgY29uc3RcblxuICAgIGNvbnN0cnVjdG9yIChcbiAgICAgICAgbG9jYXRvcnM6IFZTQ29kZUxvY2F0b3JNYXAsXG4gICAgICAgIHB1YmxpYyBzY206IFNjbVByb3ZpZGVyIHwgU2NtVmlld1xuICAgICkge1xuICAgICAgICBzdXBlcihsb2NhdG9ycywgbG9jYXRvcnMuU2NtVmlldy5tb3JlIGFzIHN0cmluZywgc2NtLmVsZW0pXG4gICAgfVxuXG4gICAgYXN5bmMgb3BlbkNvbnRleHRNZW51ICgpOiBQcm9taXNlPENvbnRleHRNZW51PiB7XG4gICAgICAgIGF3YWl0IHRoaXMuZWxlbS5jbGljaygpXG4gICAgICAgIGNvbnN0IHNoYWRvd1Jvb3RIb3N0ID0gYXdhaXQgdGhpcy5zY20uZWxlbS4kJCgnc2hhZG93LXJvb3QtaG9zdCcpXG4gICAgICAgIGF3YWl0IGJyb3dzZXIua2V5cygnRXNjYXBlJylcblxuICAgICAgICBpZiAoc2hhZG93Um9vdEhvc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGF3YWl0IHRoaXMuZWxlbS5nZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKSAhPT0gJ3RydWUnKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5lbGVtLmNsaWNrKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSAkKGF3YWl0IGJyb3dzZXIuZXhlY3V0ZSgncmV0dXJuIGFyZ3VtZW50c1swXS5zaGFkb3dSb290Jywgc2hhZG93Um9vdEhvc3RbMF0pKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250ZXh0TWVudSh0aGlzLmxvY2F0b3JNYXAsIHNoYWRvd1Jvb3QpLndhaXQoKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5vcGVuQ29udGV4dE1lbnUoKVxuICAgIH1cbn1cbiJdfQ==