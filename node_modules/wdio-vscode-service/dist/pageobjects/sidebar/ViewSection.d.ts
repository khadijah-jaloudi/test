import type { ChainablePromiseElement } from 'webdriverio';
import { ContextMenu, ViewContent, ViewItem, WelcomeContentSection } from '../index.js';
import { IPageDecorator, BasePage, VSCodeLocatorMap } from '../utils.js';
import { ViewSection as ViewSectionLocators, ExtensionsViewSection as ExtensionsViewSectionLocators, CustomTreeSection as CustomTreeSectionLocators, DefaultTreeSection as DefaultTreeSectionLocators } from '../../locators/1.73.0.js';
/**
 * @hidden
 */
export type AllViewSectionLocators = (typeof ViewSectionLocators & typeof ExtensionsViewSectionLocators & typeof CustomTreeSectionLocators & typeof DefaultTreeSectionLocators);
export interface ViewSection extends IPageDecorator<AllViewSectionLocators> {
}
/**
 * Page object representing a collapsible content section of the side bar view
 *
 * @category Sidebar
 */
export declare abstract class ViewSection extends BasePage<AllViewSectionLocators> {
    content: ViewContent;
    constructor(locators: VSCodeLocatorMap, panel: ChainablePromiseElement<WebdriverIO.Element>, content: ViewContent);
    /**
     * Get the title of the section as string
     * @returns Promise resolving to section title
     */
    getTitle(): Promise<string>;
    /**
     * Expand the section if collapsed
     * @returns Promise resolving when the section is expanded
     */
    expand(): Promise<void>;
    /**
     * Collapse the section if expanded
     * @returns Promise resolving when the section is collapsed
     */
    collapse(): Promise<void>;
    /**
     * Finds whether the section is expanded
     * @returns Promise resolving to true/false
     */
    isExpanded(): Promise<boolean>;
    /**
     * Finds [Welcome Content](https://code.visualstudio.com/api/extension-guides/tree-view#welcome-content)
     * present in this ViewSection and returns it. If none is found, then `undefined` is returned
     *
     */
    findWelcomeContent(): Promise<WelcomeContentSection | undefined>;
    /**
     * Retrieve all items currently visible in the view section.
     * Note that any item currently beyond the visible list, i.e. not scrolled to, will not be retrieved.
     * @returns Promise resolving to array of ViewItem objects
     */
    abstract getVisibleItems(): Promise<ViewItem[]>;
    /**
     * Find an item in this view section by label. Does not perform recursive search through the whole tree.
     * Does however scroll through all the expanded content. Will find items beyond the current scroll range.
     * @param label Label of the item to search for.
     * @param maxLevel Limit how deep the algorithm should look into any expanded items, default unlimited (0)
     * @returns Promise resolving to ViewItem object is such item exists, undefined otherwise
     */
    abstract findItem(label: string, maxLevel?: number): Promise<ViewItem | undefined>;
    /**
     * Open an item with a given path represented by a sequence of labels
     *
     * e.g to open 'file' inside 'folder', call
     * openItem('folder', 'file')
     *
     * The first item is only searched for directly within the root element (depth 1).
     * The label sequence is handled in order. If a leaf item (a file for example) is found in the middle
     * of the sequence, the rest is ignored.
     *
     * If the item structure is flat, use the item's title to search by.
     *
     * @param path Sequence of labels that make up the path to a given item.
     * @returns Promise resolving to array of ViewItem objects representing the last item's children.
     * If the last item is a leaf, empty array is returned.
     */
    abstract openItem(...path: string[]): Promise<ViewItem[]>;
    /**
     * Retrieve the action buttons on the section's header
     * @returns Promise resolving to array of ViewPanelAction objects
     */
    getActions(): Promise<ViewPanelAction[]>;
    /**
     * Retrieve an action button on the sections's header by its label
     * @param label label/title of the button
     * @returns ViewPanelAction object if found, undefined otherwise
     */
    getAction(label: string): Promise<ViewPanelAction | undefined>;
    /**
     * Click on the More Actions... item if it exists
     *
     * @returns ContextMenu page object if the action succeeds, undefined otherwise
     */
    moreActions(): Promise<ContextMenu | undefined>;
    private isHeaderHidden;
}
export interface ViewPanelAction extends IPageDecorator<typeof ViewSectionLocators> {
}
/**
 * Action button on the header of a view section
 *
 * @category Sidebar
 */
export declare class ViewPanelAction extends BasePage<typeof ViewSectionLocators> {
    /**
     * @private
     */
    locatorKey: "ViewSection";
    constructor(locators: VSCodeLocatorMap, element: ChainablePromiseElement<WebdriverIO.Element>, viewPart: ViewSection);
    /**
     * Get label of the action button
     */
    getLabel(): Promise<string>;
    wait(timeout?: number): Promise<this>;
}
//# sourceMappingURL=ViewSection.d.ts.map