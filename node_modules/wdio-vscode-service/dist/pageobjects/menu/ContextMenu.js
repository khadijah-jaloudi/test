var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Menu, MenuItem } from '../index.js';
import { PageDecorator, sleep } from '../utils.js';
import { ContextMenu as ContextMenuLocators } from '../../locators/1.73.0.js';
/**
 * Object representing a context menu
 *
 * @category Menu
 */
export let ContextMenu = class ContextMenu extends Menu {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'ContextMenu';
    }
    /**
     * Get context menu item by name
     * @param name name of the item to search by
     * @returns Promise resolving to ContextMenuItem object
     */
    async getItem(name) {
        try {
            const items = await this.getItems();
            for (const item of items) {
                if (await item.getLabel() === name) {
                    return item;
                }
            }
            return undefined;
        }
        catch (err) {
            return undefined;
        }
    }
    /**
     * Get all context menu items
     * @returns Promise resolving to array of ContextMenuItem objects
     */
    async getItems() {
        const items = [];
        const elements = await this.itemElement$$;
        for (const element of elements) {
            const classProperty = await element.getAttribute('class');
            if (classProperty.indexOf('disabled') < 0) {
                const item = new ContextMenuItem(this.locatorMap, 
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                element, this);
                await item.wait();
                items.push(item);
            }
        }
        return items;
    }
    /**
     * Close the context menu
     * @returns Promise resolving when the menu is closed
     */
    async close() {
        await browser.keys('Escape');
        await this.elem.waitForDisplayed({ reverse: true });
        // Todo(Christian): maybe handle stale element exception
    }
    /**
     * Wait for the menu to appear and load all its items
     */
    async wait(timeout = 5000) {
        await (await this.elem).waitForDisplayed({ timeout });
        let items = (await this.getItems()).length;
        await browser.waitUntil(async () => {
            const temp = (await this.getItems()).length;
            if (temp === items) {
                return true;
            }
            items = temp;
            return false;
        }, { timeout: 1000 });
        return this;
    }
};
ContextMenu = __decorate([
    PageDecorator(ContextMenuLocators)
], ContextMenu);
/**
 * Object representing an item of a context menu
 *
 * @category Menu
 */
export let ContextMenuItem = class ContextMenuItem extends MenuItem {
    constructor(locators, base, parentMenu) {
        super(locators, base, parentMenu.elem);
        this.parentMenu = parentMenu;
        /**
         * @private
         */
        this.locatorKey = 'ContextMenu';
        this.label = '';
    }
    async select() {
        const nesting = await this.isNesting();
        await this.elem.click();
        await sleep(500);
        if (nesting) {
            const menu = new ContextMenu(this.locatorMap, this.elem);
            await menu.wait();
            return menu;
        }
        return undefined;
    }
    async getLabel() {
        const labelItem = await this.itemLabel$;
        return labelItem.getAttribute(this.locators.itemText);
    }
    async isNesting() {
        try {
            await this.itemNesting$.waitForDisplayed();
            return true;
        }
        catch (err) {
            return false;
        }
    }
};
ContextMenuItem = __decorate([
    PageDecorator(ContextMenuLocators)
], ContextMenuItem);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29udGV4dE1lbnUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcGFnZW9iamVjdHMvbWVudS9Db250ZXh0TWVudS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFFQSxPQUFPLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxNQUFNLGFBQWEsQ0FBQTtBQUM1QyxPQUFPLEVBQ0gsYUFBYSxFQUFvQyxLQUFLLEVBQ3pELE1BQU0sYUFBYSxDQUFBO0FBQ3BCLE9BQU8sRUFBRSxXQUFXLElBQUksbUJBQW1CLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQTtBQUc3RTs7OztHQUlHO0FBRUksV0FBTSxXQUFXLEdBQWpCLE1BQU0sV0FBWSxTQUFRLElBQWdDO0lBQTFEOztRQUNIOztXQUVHO1FBQ0ksZUFBVSxHQUFHLGFBQXNCLENBQUE7SUF3RTlDLENBQUM7SUF0RUc7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxPQUFPLENBQUUsSUFBWTtRQUN2QixJQUFJO1lBQ0EsTUFBTSxLQUFLLEdBQUcsTUFBTSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUE7WUFDbkMsS0FBSyxNQUFNLElBQUksSUFBSSxLQUFLLEVBQUU7Z0JBQ3RCLElBQUksTUFBTSxJQUFJLENBQUMsUUFBUSxFQUFFLEtBQUssSUFBSSxFQUFFO29CQUNoQyxPQUFPLElBQUksQ0FBQTtpQkFDZDthQUNKO1lBRUQsT0FBTyxTQUFTLENBQUE7U0FDbkI7UUFBQyxPQUFPLEdBQUcsRUFBRTtZQUNWLE9BQU8sU0FBUyxDQUFBO1NBQ25CO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxRQUFRO1FBQ1YsTUFBTSxLQUFLLEdBQXNCLEVBQUUsQ0FBQTtRQUNuQyxNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxhQUFhLENBQUE7UUFFekMsS0FBSyxNQUFNLE9BQU8sSUFBSSxRQUFRLEVBQUU7WUFDNUIsTUFBTSxhQUFhLEdBQUcsTUFBTSxPQUFPLENBQUMs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SUFFTyxLQUFLLENBQUMsU0FBUztRQUNuQixJQUFJO1lBQ0EsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLGdCQUFnQixFQUFFLENBQUE7WUFDMUMsT0FBTyxJQUFJLENBQUE7U0FDZDtRQUFDLE9BQU8sR0FBRyxFQUFFO1lBQ1YsT0FBTyxLQUFLLENBQUE7U0FDZjtJQUNMLENBQUM7Q0FDSixDQUFBO0FBeENZLGVBQWU7SUFEM0IsYUFBYSxDQUFDLG1CQUFtQixDQUFDO0dBQ3RCLGVBQWUsQ0F3QzNCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDaGFpbmFibGVQcm9taXNlRWxlbWVudCB9IGZyb20gJ3dlYmRyaXZlcmlvJ1xuXG5pbXBvcnQgeyBNZW51LCBNZW51SXRlbSB9IGZyb20gJy4uL2luZGV4LmpzJ1xuaW1wb3J0IHtcbiAgICBQYWdlRGVjb3JhdG9yLCBJUGFnZURlY29yYXRvciwgVlNDb2RlTG9jYXRvck1hcCwgc2xlZXBcbn0gZnJvbSAnLi4vdXRpbHMuanMnXG5pbXBvcnQgeyBDb250ZXh0TWVudSBhcyBDb250ZXh0TWVudUxvY2F0b3JzIH0gZnJvbSAnLi4vLi4vbG9jYXRvcnMvMS43My4wLmpzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRleHRNZW51IGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8dHlwZW9mIENvbnRleHRNZW51TG9jYXRvcnM+IHt9XG4vKipcbiAqIE9iamVjdCByZXByZXNlbnRpbmcgYSBjb250ZXh0IG1lbnVcbiAqXG4gKiBAY2F0ZWdvcnkgTWVudVxuICovXG5AUGFnZURlY29yYXRvcihDb250ZXh0TWVudUxvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIENvbnRleHRNZW51IGV4dGVuZHMgTWVudTx0eXBlb2YgQ29udGV4dE1lbnVMb2NhdG9ycz4ge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnQ29udGV4dE1lbnUnIGFzIGNvbnN0XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29udGV4dCBtZW51IGl0ZW0gYnkgbmFtZVxuICAgICAqIEBwYXJhbSBuYW1lIG5hbWUgb2YgdGhlIGl0ZW0gdG8gc2VhcmNoIGJ5XG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gQ29udGV4dE1lbnVJdGVtIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIGdldEl0ZW0gKG5hbWU6IHN0cmluZyk6IFByb21pc2U8TWVudUl0ZW08dHlwZW9mIENvbnRleHRNZW51TG9jYXRvcnM+IHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHRoaXMuZ2V0SXRlbXMoKVxuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF3YWl0IGl0ZW0uZ2V0TGFiZWwoKSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgY29udGV4dCBtZW51IGl0ZW1zXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYXJyYXkgb2YgQ29udGV4dE1lbnVJdGVtIG9iamVjdHNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRJdGVtcyAoKTogUHJvbWlzZTxDb250ZXh0TWVudUl0ZW1bXT4ge1xuICAgICAgICBjb25zdCBpdGVtczogQ29udGV4dE1lbnVJdGVtW10gPSBbXVxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IGF3YWl0IHRoaXMuaXRlbUVsZW1lbnQkJFxuXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NQcm9wZXJ0eSA9IGF3YWl0IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpXG4gICAgICAgICAgICBpZiAoY2xhc3NQcm9wZXJ0eS5pbmRleE9mKCdkaXNhYmxlZCcpIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBuZXcgQ29udGV4dE1lbnVJdGVtKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2F0b3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgYXMgYW55LFxuICAgICAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGF3YWl0IGl0ZW0ud2FpdCgpXG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBjb250ZXh0IG1lbnVcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBtZW51IGlzIGNsb3NlZFxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlICgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgYXdhaXQgYnJvd3Nlci5rZXlzKCdFc2NhcGUnKVxuICAgICAgICBhd2FpdCB0aGlzLmVsZW0ud2FpdEZvckRpc3BsYXllZCh7IHJldmVyc2U6IHRydWUgfSlcbiAgICAgICAgLy8gVG9kbyhDaHJpc3RpYW4pOiBtYXliZSBoYW5kbGUgc3RhbGUgZWxlbWVudCBleGNlcHRpb25cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXYWl0IGZvciB0aGUgbWVudSB0byBhcHBlYXIgYW5kIGxvYWQgYWxsIGl0cyBpdGVtc1xuICAgICAqL1xuICAgIGFzeW5jIHdhaXQgKHRpbWVvdXQgPSA1MDAwKTogUHJvbWlzZTx0aGlzPiB7XG4gICAgICAgIGF3YWl0IChhd2FpdCB0aGlzLmVsZW0pLndhaXRGb3JEaXNwbGF5ZWQoeyB0aW1lb3V0IH0pXG4gICAgICAgIGxldCBpdGVtcyA9IChhd2FpdCB0aGlzLmdldEl0ZW1zKCkpLmxlbmd0aFxuICAgICAgICBhd2FpdCBicm93c2VyLndhaXRVbnRpbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wID0gKGF3YWl0IHRoaXMuZ2V0SXRlbXMoKSkubGVuZ3RoXG4gICAgICAgICAgICBpZiAodGVtcCA9PT0gaXRlbXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbXMgPSB0ZW1wXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSwgeyB0aW1lb3V0OiAxMDAwIH0pXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRleHRNZW51SXRlbSBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBDb250ZXh0TWVudUxvY2F0b3JzPiB7fVxuLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50aW5nIGFuIGl0ZW0gb2YgYSBjb250ZXh0IG1lbnVcbiAqXG4gKiBAY2F0ZWdvcnkgTWVudVxuICovXG5AUGFnZURlY29yYXRvcihDb250ZXh0TWVudUxvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIENvbnRleHRNZW51SXRlbSBleHRlbmRzIE1lbnVJdGVtPHR5cGVvZiBDb250ZXh0TWVudUxvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdDb250ZXh0TWVudScgYXMgY29uc3RcbiAgICBwdWJsaWMgbGFiZWwgPSAnJ1xuXG4gICAgY29uc3RydWN0b3IgKFxuICAgICAgICBsb2NhdG9yczogVlNDb2RlTG9jYXRvck1hcCxcbiAgICAgICAgYmFzZTogQ2hhaW5hYmxlUHJvbWlzZUVsZW1lbnQ8V2ViZHJpdmVySU8uRWxlbWVudD4sXG4gICAgICAgIHB1YmxpYyBwYXJlbnRNZW51OiBNZW51PHR5cGVvZiBDb250ZXh0TWVudUxvY2F0b3JzPlxuICAgICkge1xuICAgICAgICBzdXBlcihsb2NhdG9ycywgYmFzZSwgcGFyZW50TWVudS5lbGVtKVxuICAgIH1cblxuICAgIGFzeW5jIHNlbGVjdCAoKSB7XG4gICAgICAgIGNvbnN0IG5lc3RpbmcgPSBhd2FpdCB0aGlzLmlzTmVzdGluZygpXG4gICAgICAgIGF3YWl0IHRoaXMuZWxlbS5jbGljaygpXG4gICAgICAgIGF3YWl0IHNsZWVwKDUwMClcbiAgICAgICAgaWYgKG5lc3RpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lbnUgPSBuZXcgQ29udGV4dE1lbnUodGhpcy5sb2NhdG9yTWFwLCB0aGlzLmVsZW0pXG4gICAgICAgICAgICBhd2FpdCBtZW51LndhaXQoKVxuICAgICAgICAgICAgcmV0dXJuIG1lbnVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0TGFiZWwgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IGxhYmVsSXRlbSA9IGF3YWl0IHRoaXMuaXRlbUxhYmVsJFxuICAgICAgICByZXR1cm4gbGFiZWxJdGVtLmdldEF0dHJpYnV0ZSh0aGlzLmxvY2F0b3JzLml0ZW1UZXh0KVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgaXNOZXN0aW5nICgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaXRlbU5lc3RpbmckLndhaXRGb3JEaXNwbGF5ZWQoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==