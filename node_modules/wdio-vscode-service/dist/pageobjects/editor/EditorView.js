var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { TextEditor, DiffEditor, SettingsEditor } from '../index.js';
import { PageDecorator, BasePage, ElementWithContextMenu } from '../utils.js';
import { EditorView as EditorViewLocators, Editor as EditorLocatorsObj } from '../../locators/1.73.0.js';
/**
 * View handling the open editors
 *
 * @category Editor
 */
export let EditorView = class EditorView extends BasePage {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'EditorView';
    }
    /**
     * Switch to an editor tab with the given title
     * @param title title of the tab
     * @param groupIndex zero based index for the editor group (0 for the left most group)
     * @returns Promise resolving to Editor object
     */
    async openEditor(title, groupIndex = 0) {
        const group = await this.getEditorGroup(groupIndex);
        return group.openEditor(title);
    }
    /**
     * Close an editor tab with the given title
     * @param title title of the tab
     * @param groupIndex zero based index for the editor group (0 for the left most group)
     * @returns Promise resolving when the tab's close button is pressed
     */
    async closeEditor(title, groupIndex = 0) {
        const group = await this.getEditorGroup(groupIndex);
        return group.closeEditor(title);
    }
    /**
     * Close all open editor tabs
     * @param groupIndex optional index to specify an editor group
     * @returns Promise resolving once all tabs have had their close button pressed
     */
    async closeAllEditors(groupIndex) {
        let groups = await this.getEditorGroups();
        if (groupIndex !== undefined) {
            await groups[0].closeAllEditors();
            return;
        }
        while (groups.length > 0 && (await groups[0].getOpenEditorTitles()).length > 0) {
            await groups[0].closeAllEditors();
            groups = await this.getEditorGroups();
        }
    }
    /**
     * Retrieve all open editor tab titles in an array
     * @param groupIndex optional index to specify an editor group, if left empty will search all groups
     * @returns Promise resolving to array of editor titles
     */
    async getOpenEditorTitles(groupIndex) {
        const groups = await this.getEditorGroups();
        if (groupIndex !== undefined) {
            return groups[groupIndex].getOpenEditorTitles();
        }
        const titles = [];
        for (const group of groups) {
            titles.push(...(await group.getOpenEditorTitles()));
        }
        return titles;
    }
    /**
     * Retrieve an editor tab from a given group by title
     * @param title title of the tab
     * @param groupIndex zero based index of the editor group, default 0 (leftmost one)
     * @returns promise resolving to EditorTab object
     */
    async getTabByTitle(title, groupIndex = 0) {
        const group = await this.getEditorGroup(groupIndex);
        return group.getTabByTitle(title);
    }
    /**
     * Retrieve all open editor tabs
     * @param groupIndex index of group to search for tabs, if left undefined, all groups are searched
     * @returns promise resolving to EditorTab list
     */
    async getOpenTabs(groupIndex) {
        const groups = await this.getEditorGroups();
        if (groupIndex !== undefined) {
            return groups[groupIndex].getOpenTabs();
        }
        const tabs = [];
        for (const group of groups) {
            tabs.push(...(await group.getOpenTabs()));
        }
        return tabs;
    }
    /**
     * Retrieve the active editor tab
     * @returns promise resolving to EditorTab object, undefined if no tab is active
     */
    async getActiveTab() {
        const tabs = await this.getOpenTabs();
        const klasses = await Promise.all(tabs.map(async (tab) => tab.elem.getAttribute('class')));
        const index = klasses.findIndex((klass) => klass.indexOf('active') > -1);
        if (index > -1) {
            return tabs[index];
        }
        return undefined;
    }
    /**
     * Retrieve all editor groups in a list, sorted left to right
     * @returns promise resolving to an array of EditorGroup objects
     */
    async getEditorGroups() {
        const elements = await this.editorGroup$$;
        const groups = await Promise.all(elements.map(async (element) => (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        new EditorGroup(this.locatorMap, element, this).wait())));
        // sort the groups by x coordinates, so the leftmost is always at index 0
        for (let i = 0; i < groups.length - 1; i += 1) {
            for (let j = 0; j < groups.length - i - 1; j += 1) {
                if ((await groups[j].elem.getLocation('x')) > (await groups[j + 1].elem.getLocation('x'))) {
                    const temp = groups[j];
                    groups[j] = groups[j + 1];
                    groups[j + 1] = temp;
                }
            }
        }
        return groups;
    }
    /**
     * Retrieve an editor group with a given index (counting from left to right)
     * @param index zero based index of the editor group (leftmost group has index 0)
     * @returns promise resolving to an EditorGroup object
     */
    async getEditorGroup(index) {
        return (await this.getEditorGroups())[index];
    }
    /**
     * Get editor actions of a select editor group
     * @param groupIndex zero based index of the editor group (leftmost group has index 0), default 0
     * @returns promise resolving to list of WebElement objects
     */
    async getActions(groupIndex = 0) {
        const group = await this.getEditorGroup(groupIndex);
        return group.getActions();
    }
    /**
     * Get editor action of a select editor group, search by title
     * @param groupIndex zero based index of the editor group (leftmost group has index 0), default 0
     * @returns promise resolving to WebElement object if found, undefined otherwise
     */
    async getAction(title, groupIndex = 0) {
        const group = await this.getEditorGroup(groupIndex);
        return group.getAction(title);
    }
};
EditorView = __decorate([
    PageDecorator(EditorViewLocators)
], EditorView);
/**
 * Page object representing an editor group
 *
 * @category Editor
 */
export let EditorGroup = class EditorGroup extends BasePage {
    constructor(locators, element, view = new EditorView(locators)) {
        super(locators, element);
        this.view = view;
        /**
         * @private
         */
        this.locatorKey = 'EditorView';
    }
    /**
     * Switch to an editor tab with the given title
     * @param title title of the tab
     * @returns Promise resolving to Editor object
     */
    async openEditor(title) {
        const tab = await this.getTabByTitle(title);
        await tab.select();
        if (await this.settingsEditor$.isExisting()) {
            return new SettingsEditor(this.locatorMap, this).wait();
        }
        if (await this.diffEditor$.isExisting()) {
            return new DiffEditor(this.locatorMap, this.locatorMap.Editor.elem, this).wait();
        }
        return new TextEditor(this.locatorMap, this.locatorMap.Editor.elem, this).wait();
    }
    /**
     * Close an editor tab with the given title
     * @param title title of the tab
     * @returns Promise resolving when the tab's close button is pressed
     */
    async closeEditor(title) {
        const tab = await this.getTabByTitle(title);
        await tab.elem.moveTo();
        const closeButton = await tab.elem.$(this.locators.closeTab);
        await closeButton.click();
    }
    /**
     * Close all open editor tabs
     * @returns Promise resolving once all tabs have had their close button pressed
     */
    async closeAllEditors() {
        let titles = await this.getOpenEditorTitles();
        while (titles.length > 0) {
            await this.closeEditor(titles[0]);
            try {
                // check if the group still exists
                await this.elem.getTagName();
            }
            catch (err) {
                break;
            }
            titles = await this.getOpenEditorTitles();
        }
    }
    /**
     * Retrieve all open editor tab titles in an array
     * @returns Promise resolving to array of editor titles
     */
    async getOpenEditorTitles() {
        const tabs = await this.tab$$;
        const titles = [];
        for (const tab of tabs) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            const title = await new EditorTab(this.locatorMap, tab, this.view).getTitle();
            titles.push(title);
        }
        return titles;
    }
    /**
     * Retrieve an editor tab by title
     * @param title title of the tab
     * @returns promise resolving to EditorTab object
     */
    async getTabByTitle(title) {
        const tabs = await this.tab$$;
        const availableLabels = new Set();
        for (const tab of tabs) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            const editorTab = new EditorTab(this.locatorMap, tab, this.view);
            const label = await editorTab.getTitle();
            availableLabels.add(label);
            if (label === title) {
                return editorTab;
            }
        }
        throw new Error(`No editor with title '${title}' found, `
            + `available editor were: ${[...availableLabels].join(', ')}`);
    }
    /**
     * Retrieve all open editor tabs
     * @returns promise resolving to EditorTab list
     */
    async getOpenTabs() {
        const tabs = await this.tab$$;
        return Promise.all(tabs.map(async (tab) => (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        new EditorTab(this.locatorMap, tab, this.view).wait())));
    }
    /**
     * Retrieve the active editor tab
     * @returns promise resolving to EditorTab object, undefined if no tab is active
     */
    async getActiveTab() {
        const tabs = await this.getOpenTabs();
        const klasses = await Promise.all(tabs.map(async (tab) => tab.elem.getAttribute('class')));
        const index = klasses.findIndex((klass) => klass.indexOf('active') > -1);
        if (index > -1) {
            return tabs[index];
        }
        return undefined;
    }
    /**
     * Retrieve the editor action buttons as WebElements
     * @returns promise resolving to list of WebElement objects
     */
    async getActions() {
        return this.actionContainer$.$$(this.locators.actionItem);
    }
    /**
     * Find an editor action button by title
     * @param title title of the button
     * @returns promise resolving to WebElement representing the button if found, undefined otherwise
     */
    async getAction(title) {
        const actions = await this.getActions();
        for (const item of actions) {
            if (await item.getAttribute('title') === title) {
                return item;
            }
        }
        return undefined;
    }
};
EditorGroup = __decorate([
    PageDecorator(EditorViewLocators)
], EditorGroup);
/**
 * Page object for editor view tab
 *
 * @category Editor
 */
export let EditorTab = class EditorTab extends ElementWithContextMenu {
    constructor(locators, element, view) {
        super(locators, element);
        this.view = view;
        /**
         * @private
         */
        this.locatorKey = 'Editor';
    }
    /**
     * Get the tab title as string
     */
    async getTitle() {
        return this.title$.getText();
    }
    /**
     * Select (click) the tab
     */
    async select() {
        await this.elem.click();
    }
};
EditorTab = __decorate([
    PageDecorator(EditorLocatorsObj)
], EditorTab);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRWRpdG9yVmlldy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wYWdlb2JqZWN0cy9lZGl0b3IvRWRpdG9yVmlldy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFFQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxjQUFjLEVBQUUsTUFBTSxhQUFhLENBQUE7QUFDcEUsT0FBTyxFQUNILGFBQWEsRUFBa0IsUUFBUSxFQUFFLHNCQUFzQixFQUNsRSxNQUFNLGFBQWEsQ0FBQTtBQUNwQixPQUFPLEVBQ0gsVUFBVSxJQUFJLGtCQUFrQixFQUNoQyxNQUFNLElBQUksaUJBQWlCLEVBQzlCLE1BQU0sMEJBQTBCLENBQUE7QUFHakM7Ozs7R0FJRztBQUVJLFdBQU0sVUFBVSxHQUFoQixNQUFNLFVBQVcsU0FBUSxRQUFtQztJQUE1RDs7UUFDSDs7V0FFRztRQUNJLGVBQVUsR0FBRyxZQUFxQixDQUFBO0lBNEo3QyxDQUFDO0lBMUpHOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLFVBQVUsQ0FBRSxLQUFhLEVBQUUsVUFBVSxHQUFHLENBQUM7UUFDM0MsTUFBTSxLQUFLLEdBQUcsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFBO1FBQ25ELE9BQU8sS0FBSyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQTtJQUNsQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxLQUFLLENBQUMsV0FBVyxDQUFFLEtBQWEsRUFBRSxVQUFVLEdBQUcsQ0FBQztRQUM1QyxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUE7UUFDbkQsT0FBTyxLQUFLLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFBO0lBQ25DLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLGVBQWUsQ0FBRSxVQUFtQjtRQUN0QyxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQTtRQUN6QyxJQUFJLFVBQVUsS0FBSyxTQUFTLEVBQUU7WUFDMUIsTUFBTSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsZUFBZSxFQUFFLENBQUE7WUFDakMsT0FBTTtTQUNUO1FBRUQsT0FBTyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLG1CQUFtQixFQUFFLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQzVFLE1BQU0sTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsRUFBRSxDQUFBO1lBQ2pDLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQTtTQUN4QztJQUNMLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLG1CQUFtQixDQUFFLFVBQW1CO1FBQzFDLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFBO1FBQzNDLElBQUksVUFBVSxLQUFLLFNBQVMsRUFBRTtZQUMxQixPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxtQkFBbUIsRUFBRSxDQUFBO1NBQ2xEO1FBQ0QsTUFBTSxNQUFNLEdBQWEsRUFBRSxDQUFBO1FBQzNCLEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxFQUFFO1lBQ3hCLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sS0FBSyxDQUFDLG1CQUFtQixFQUFFLENBQUMsQ0FBQyxDQUFBO1NBQ3REO1FBQ0QsT0FBTyxNQUFNLENBQUE7SUFDakIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLGFBQWEsQ0FBRSxLQUFhLEVBQUUsVUFBVSxHQUFHLENBQUM7UUFDOUMsTUFBTSxLQUFLLEdBQUcsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFBO1FBQ25ELE9BQU8sS0FBSyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQTtJQUNyQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxXQUFXLENBQUUsVUFBbUI7UUFDbEMsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUE7UUFDM0MsSUFBSSxVQUFVLEtBQUssU0FBUyxFQUFFO1lBQzFCLE9BQU8sTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFBO1NBQzFDO1FBQ0QsTUFBTSxJQUFJLEdBQWdCLEVBQUUsQ0FBQTtRQUM1QixLQUFLLE1BQU0sS0FBSyxJQUFJLE1BQU0sRUFBRTtZQUN4QixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUE7U0FDNUM7UUFDRCxPQUFPLElBQUksQ0FBQTtJQUNmLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsWUFBWTtRQUNkLE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFBO1FBQ3JDLE1BQU0sT0FBTyxHQUFHLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQTtRQUMxRixNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUE7UUFFeEUsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEVBQUU7WUFDWixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQTtTQUNyQjtRQUNELE9BQU8sU0FBUyxDQUFBO0lBQ3BCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsZUFBZTtRQUNqQixNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxhQUFhLENBQUE7UUFDekMsTUFBTSxNQUFNLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUM1QixRQUFRLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsRUFBRSxDQUFDO1FBQzVCLGlFQUFpRTtRQUNqRSxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLE9BQWMsRUFBRSxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FDaEUsQ0FBQyxDQUNMLENBQUE7UUFFRCx5RUFBeUU7UUFDekUsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDM0MsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUMvQyxJQUFJLENBQUMsTUFBTSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtvQkFDdkYsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFBO29CQUN0QixNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQTtvQkFDekIsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUE7aUJBQ3ZCO2FBQ0o7U0FDSjtRQUNELE9BQU8sTUFBTSxDQUFBO0lBQ2pCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLGNBQWMsQ0FBRSxLQUFhO1FBQy9CLE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFBO0lBQ2hELENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLFVBQVUsQ0FBRSxVQUFVLEdBQUcsQ0FBQztRQUM1QixNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUE7UUFDbkQsT0FBTyxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUE7SUFDN0IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsU0FBUyxDQUFFLEtBQWEsRUFBRSxVQUFVLEdBQUcsQ0FBQztRQUMxQyxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUE7UUFDbkQsT0FBTyxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFBO0lBQ2pDLENBQUM7Q0FDSixDQUFBO0FBaEtZLFVBQVU7SUFEdEIsYUFBYSxDQUFDLGtCQUFrQixDQUFDO0dBQ3JCLFVBQVUsQ0FnS3RCO0FBR0Q7Ozs7R0FJRztBQUVJLFdBQU0sV0FBVyxHQUFqQixNQUFNLFdBQVksU0FBUSxRQUFtQztJQU1oRSxZQUNJLFFBQTBCLEVBQzFCLE9BQXFELEVBQzlDLE9BQU8sSUFBSSxVQUFVLENBQUMsUUFBUSxDQUFDO1FBRXRDLEtBQUssQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUE7UUFGakIsU0FBSSxHQUFKLElBQUksQ0FBMkI7UUFSMUM7O1dBRUc7UUFDSSxlQUFVLEdBQUcsWUFBcUIsQ0FBQTtJQVF6QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxVQUFVLENBQUUsS0FBYTtRQUMzQixNQUFNLEdBQUcsR0FBRyxNQUFNLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUE7UUFDM0MsTUFBTSxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUE7UUFFbEIsSUFBSSxNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsVUFBVSxFQUFFLEVBQUU7WUFDekMsT0FBTyxJQUFJLGNBQWMsQ0FDckIsSUFBSSxDQUFDLFVBQVUsRUFDZixJQUFJLENBQ1AsQ0FBQyxJQUFJLEVBQUUsQ0FBQTtTQUNYO1FBRUQsSUFBSSxNQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUFFLEVBQUU7WUFDckMsT0FBTyxJQUFJLFVBQVUsQ0FDakIsSUFBSSxDQUFDLFVBQVUsRUFDZixJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFjLEVBQ3JDLElBQUksQ0FDUCxDQUFDLElBQUksRUFBRSxDQUFBO1NBQ1g7UUFFRCxPQUFPLElBQUksVUFBVSxDQUNqQixJQUFJLENBQUMsVUFBVSxFQUNmLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQWMsRUFDckMsSUFBSSxDQUNQLENBQUMsSUFBSSxFQUFFLENBQUE7SUFDWixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxXQUFXLENBQUUsS0FBYTtRQUM1QixNQUFNLEdBQUcsR0FBRyxNQUFNLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUE7UUFDM0MsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFBO1FBQ3ZCLE1BQU0sV0FBVyxHQUFHLE1BQU0sR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQTtRQUM1RCxNQUFNLFdBQVcsQ0FBQyxLQUFLLEVBQUUsQ0FBQTtJQUM3QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLGVBQWU7UUFDakIsSUFBSSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQTtRQUM3QyxPQUFPLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ3RCLE1BQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtZQUNqQyxJQUFJO2dCQUNBLGtDQUFrQztnQkFDbEMsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFBO2FBQy9CO1lBQUMsT0FBTyxHQUFHLEVBQUU7Z0JBQ1YsTUFBSzthQUNSO1lBQ0QsTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUE7U0FDNUM7SUFDTCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLG1CQUFtQjtRQUNyQixNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUE7UUFDN0IsTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFBO1FBQ2pCLEtBQUssTUFBTSxHQUFHLElBQUksSUFBSSxFQUFFO1lBQ3BCLGlFQUFpRTtZQUNqRSxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsR0FBVSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQTtZQUNwRixNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFBO1NBQ3JCO1FBQ0QsT0FBTyxNQUFNLENBQUE7SUFDakIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsYUFBYSxDQUFFLEtBQWE7UUFDOUIsTUFBTSxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFBO1FBQzdCLE1BQU0sZUFBZSxHQUFHLElBQUksR0FBRyxFQUFFLENBQUE7UUFDakMsS0FBSyxNQUFNLEdBQUcsSUFBSSxJQUFJLEVBQUU7WUFDcEIsaUVBQWlFO1lBQ2pFLE1BQU0sU0FBUyxHQUFHLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsR0FBVSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTtZQUN2RSxNQUFNLEtBQUssR0FBRyxNQUFNLFNBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQTtZQUN4QyxlQUFlLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFBO1lBQzFCLElBQUksS0FBSyxLQUFLLEtBQUssRUFBRTtnQkFDakIsT0FBTyxTQUFTLENBQUE7YUFDbkI7U0FDSjtRQUNELE1BQU0sSUFBSSxLQUFLLENBQ1gseUJBQXlCLEtBQUssV0FBVztjQUN2QywwQkFBMEIsQ0FBQyxHQUFHLGVBQWUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUNoRSxDQUFBO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxXQUFXO1FBQ2IsTUFBTSxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFBO1FBQzdCLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FDZCxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDO1FBQ3BCLGlFQUFpRTtRQUNqRSxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEdBQVUsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQy9ELENBQUMsQ0FDTCxDQUFBO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxZQUFZO1FBQ2QsTUFBTSxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUE7UUFDckMsTUFBTSxPQUFPLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFBO1FBQzFGLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQTtRQUV4RSxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUMsRUFBRTtZQUNaLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFBO1NBQ3JCO1FBQ0QsT0FBTyxTQUFTLENBQUE7SUFDcEIsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUE7SUFDN0QsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsU0FBUyxDQUFFLEtBQWE7UUFDMUIsTUFBTSxPQUFPLEdBQUcsTUFBTSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUE7UUFDdkMsS0FBSyxNQUFNLElBQUksSUFBSSxPQUFPLEVBQUU7WUFDeEIsSUFBSSxNQUFNLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLEtBQUssS0FBSyxFQUFFO2dCQUM1QyxPQUFPLElBQUksQ0FBQTthQUNkO1NBQ0o7UUFDRCxPQUFPLFNBQVMsQ0FBQTtJQUNwQixDQUFDO0NBQ0osQ0FBQTtBQXBLWSxXQUFXO0lBRHZCLGFBQWEsQ0FBQyxrQkFBa0IsQ0FBQztHQUNyQixXQUFXLENBb0t2QjtBQUdEOzs7O0dBSUc7QUFFSSxXQUFNLFNBQVMsR0FBZixNQUFNLFNBQVUsU0FBUSxzQkFBZ0Q7SUFNM0UsWUFDSSxRQUEwQixFQUMxQixPQUFxRCxFQUM5QyxJQUFnQjtRQUV2QixLQUFLLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFBO1FBRmpCLFNBQUksR0FBSixJQUFJLENBQVk7UUFSM0I7O1dBRUc7UUFDSSxlQUFVLEdBQUcsUUFBaUIsQ0FBQTtJQVFyQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxLQUFLLENBQUMsUUFBUTtRQUNWLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQTtJQUNoQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxLQUFLLENBQUMsTUFBTTtRQUNSLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQTtJQUMzQixDQUFDO0NBQ0osQ0FBQTtBQTNCWSxTQUFTO0lBRHJCLGFBQWEsQ0FBQyxpQkFBaUIsQ0FBQztHQUNwQixTQUFTLENBMkJyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQ2hhaW5hYmxlUHJvbWlzZUVsZW1lbnQgfSBmcm9tICd3ZWJkcml2ZXJpbydcblxuaW1wb3J0IHsgVGV4dEVkaXRvciwgRGlmZkVkaXRvciwgU2V0dGluZ3NFZGl0b3IgfSBmcm9tICcuLi9pbmRleC5qcydcbmltcG9ydCB7XG4gICAgUGFnZURlY29yYXRvciwgSVBhZ2VEZWNvcmF0b3IsIEJhc2VQYWdlLCBFbGVtZW50V2l0aENvbnRleHRNZW51LCBWU0NvZGVMb2NhdG9yTWFwXG59IGZyb20gJy4uL3V0aWxzLmpzJ1xuaW1wb3J0IHtcbiAgICBFZGl0b3JWaWV3IGFzIEVkaXRvclZpZXdMb2NhdG9ycyxcbiAgICBFZGl0b3IgYXMgRWRpdG9yTG9jYXRvcnNPYmpcbn0gZnJvbSAnLi4vLi4vbG9jYXRvcnMvMS43My4wLmpzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEVkaXRvclZpZXcgZXh0ZW5kcyBJUGFnZURlY29yYXRvcjx0eXBlb2YgRWRpdG9yVmlld0xvY2F0b3JzPiB7fVxuLyoqXG4gKiBWaWV3IGhhbmRsaW5nIHRoZSBvcGVuIGVkaXRvcnNcbiAqXG4gKiBAY2F0ZWdvcnkgRWRpdG9yXG4gKi9cbkBQYWdlRGVjb3JhdG9yKEVkaXRvclZpZXdMb2NhdG9ycylcbmV4cG9ydCBjbGFzcyBFZGl0b3JWaWV3IGV4dGVuZHMgQmFzZVBhZ2U8dHlwZW9mIEVkaXRvclZpZXdMb2NhdG9ycz4ge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnRWRpdG9yVmlldycgYXMgY29uc3RcblxuICAgIC8qKlxuICAgICAqIFN3aXRjaCB0byBhbiBlZGl0b3IgdGFiIHdpdGggdGhlIGdpdmVuIHRpdGxlXG4gICAgICogQHBhcmFtIHRpdGxlIHRpdGxlIG9mIHRoZSB0YWJcbiAgICAgKiBAcGFyYW0gZ3JvdXBJbmRleCB6ZXJvIGJhc2VkIGluZGV4IGZvciB0aGUgZWRpdG9yIGdyb3VwICgwIGZvciB0aGUgbGVmdCBtb3N0IGdyb3VwKVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIEVkaXRvciBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBvcGVuRWRpdG9yICh0aXRsZTogc3RyaW5nLCBncm91cEluZGV4ID0gMCkge1xuICAgICAgICBjb25zdCBncm91cCA9IGF3YWl0IHRoaXMuZ2V0RWRpdG9yR3JvdXAoZ3JvdXBJbmRleClcbiAgICAgICAgcmV0dXJuIGdyb3VwLm9wZW5FZGl0b3IodGl0bGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgYW4gZWRpdG9yIHRhYiB3aXRoIHRoZSBnaXZlbiB0aXRsZVxuICAgICAqIEBwYXJhbSB0aXRsZSB0aXRsZSBvZiB0aGUgdGFiXG4gICAgICogQHBhcmFtIGdyb3VwSW5kZXggemVybyBiYXNlZCBpbmRleCBmb3IgdGhlIGVkaXRvciBncm91cCAoMCBmb3IgdGhlIGxlZnQgbW9zdCBncm91cClcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSB0YWIncyBjbG9zZSBidXR0b24gaXMgcHJlc3NlZFxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlRWRpdG9yICh0aXRsZTogc3RyaW5nLCBncm91cEluZGV4ID0gMCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBncm91cCA9IGF3YWl0IHRoaXMuZ2V0RWRpdG9yR3JvdXAoZ3JvdXBJbmRleClcbiAgICAgICAgcmV0dXJuIGdyb3VwLmNsb3NlRWRpdG9yKHRpdGxlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlIGFsbCBvcGVuIGVkaXRvciB0YWJzXG4gICAgICogQHBhcmFtIGdyb3VwSW5kZXggb3B0aW9uYWwgaW5kZXggdG8gc3BlY2lmeSBhbiBlZGl0b3IgZ3JvdXBcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyBvbmNlIGFsbCB0YWJzIGhhdmUgaGFkIHRoZWlyIGNsb3NlIGJ1dHRvbiBwcmVzc2VkXG4gICAgICovXG4gICAgYXN5bmMgY2xvc2VBbGxFZGl0b3JzIChncm91cEluZGV4PzogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGxldCBncm91cHMgPSBhd2FpdCB0aGlzLmdldEVkaXRvckdyb3VwcygpXG4gICAgICAgIGlmIChncm91cEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IGdyb3Vwc1swXS5jbG9zZUFsbEVkaXRvcnMoKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoZ3JvdXBzLmxlbmd0aCA+IDAgJiYgKGF3YWl0IGdyb3Vwc1swXS5nZXRPcGVuRWRpdG9yVGl0bGVzKCkpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IGdyb3Vwc1swXS5jbG9zZUFsbEVkaXRvcnMoKVxuICAgICAgICAgICAgZ3JvdXBzID0gYXdhaXQgdGhpcy5nZXRFZGl0b3JHcm91cHMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYWxsIG9wZW4gZWRpdG9yIHRhYiB0aXRsZXMgaW4gYW4gYXJyYXlcbiAgICAgKiBAcGFyYW0gZ3JvdXBJbmRleCBvcHRpb25hbCBpbmRleCB0byBzcGVjaWZ5IGFuIGVkaXRvciBncm91cCwgaWYgbGVmdCBlbXB0eSB3aWxsIHNlYXJjaCBhbGwgZ3JvdXBzXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYXJyYXkgb2YgZWRpdG9yIHRpdGxlc1xuICAgICAqL1xuICAgIGFzeW5jIGdldE9wZW5FZGl0b3JUaXRsZXMgKGdyb3VwSW5kZXg/OiBudW1iZXIpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIGNvbnN0IGdyb3VwcyA9IGF3YWl0IHRoaXMuZ2V0RWRpdG9yR3JvdXBzKClcbiAgICAgICAgaWYgKGdyb3VwSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdyb3Vwc1tncm91cEluZGV4XS5nZXRPcGVuRWRpdG9yVGl0bGVzKClcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aXRsZXM6IHN0cmluZ1tdID0gW11cbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiBncm91cHMpIHtcbiAgICAgICAgICAgIHRpdGxlcy5wdXNoKC4uLihhd2FpdCBncm91cC5nZXRPcGVuRWRpdG9yVGl0bGVzKCkpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aXRsZXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhbiBlZGl0b3IgdGFiIGZyb20gYSBnaXZlbiBncm91cCBieSB0aXRsZVxuICAgICAqIEBwYXJhbSB0aXRsZSB0aXRsZSBvZiB0aGUgdGFiXG4gICAgICogQHBhcmFtIGdyb3VwSW5kZXggemVybyBiYXNlZCBpbmRleCBvZiB0aGUgZWRpdG9yIGdyb3VwLCBkZWZhdWx0IDAgKGxlZnRtb3N0IG9uZSlcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byBFZGl0b3JUYWIgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgZ2V0VGFiQnlUaXRsZSAodGl0bGU6IHN0cmluZywgZ3JvdXBJbmRleCA9IDApOiBQcm9taXNlPEVkaXRvclRhYj4ge1xuICAgICAgICBjb25zdCBncm91cCA9IGF3YWl0IHRoaXMuZ2V0RWRpdG9yR3JvdXAoZ3JvdXBJbmRleClcbiAgICAgICAgcmV0dXJuIGdyb3VwLmdldFRhYkJ5VGl0bGUodGl0bGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYWxsIG9wZW4gZWRpdG9yIHRhYnNcbiAgICAgKiBAcGFyYW0gZ3JvdXBJbmRleCBpbmRleCBvZiBncm91cCB0byBzZWFyY2ggZm9yIHRhYnMsIGlmIGxlZnQgdW5kZWZpbmVkLCBhbGwgZ3JvdXBzIGFyZSBzZWFyY2hlZFxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIEVkaXRvclRhYiBsaXN0XG4gICAgICovXG4gICAgYXN5bmMgZ2V0T3BlblRhYnMgKGdyb3VwSW5kZXg/OiBudW1iZXIpOiBQcm9taXNlPEVkaXRvclRhYltdPiB7XG4gICAgICAgIGNvbnN0IGdyb3VwcyA9IGF3YWl0IHRoaXMuZ2V0RWRpdG9yR3JvdXBzKClcbiAgICAgICAgaWYgKGdyb3VwSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdyb3Vwc1tncm91cEluZGV4XS5nZXRPcGVuVGFicygpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFiczogRWRpdG9yVGFiW10gPSBbXVxuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIGdyb3Vwcykge1xuICAgICAgICAgICAgdGFicy5wdXNoKC4uLihhd2FpdCBncm91cC5nZXRPcGVuVGFicygpKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFic1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBhY3RpdmUgZWRpdG9yIHRhYlxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIEVkaXRvclRhYiBvYmplY3QsIHVuZGVmaW5lZCBpZiBubyB0YWIgaXMgYWN0aXZlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWN0aXZlVGFiICgpOiBQcm9taXNlPEVkaXRvclRhYiB8IHVuZGVmaW5lZD4ge1xuICAgICAgICBjb25zdCB0YWJzID0gYXdhaXQgdGhpcy5nZXRPcGVuVGFicygpXG4gICAgICAgIGNvbnN0IGtsYXNzZXMgPSBhd2FpdCBQcm9taXNlLmFsbCh0YWJzLm1hcChhc3luYyAodGFiKSA9PiB0YWIuZWxlbS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpKVxuICAgICAgICBjb25zdCBpbmRleCA9IGtsYXNzZXMuZmluZEluZGV4KChrbGFzcykgPT4ga2xhc3MuaW5kZXhPZignYWN0aXZlJykgPiAtMSlcblxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhYnNbaW5kZXhdXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGFsbCBlZGl0b3IgZ3JvdXBzIGluIGEgbGlzdCwgc29ydGVkIGxlZnQgdG8gcmlnaHRcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byBhbiBhcnJheSBvZiBFZGl0b3JHcm91cCBvYmplY3RzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RWRpdG9yR3JvdXBzICgpOiBQcm9taXNlPEVkaXRvckdyb3VwW10+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBhd2FpdCB0aGlzLmVkaXRvckdyb3VwJCRcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBlbGVtZW50cy5tYXAoYXN5bmMgKGVsZW1lbnQpID0+IChcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgICAgIG5ldyBFZGl0b3JHcm91cCh0aGlzLmxvY2F0b3JNYXAsIGVsZW1lbnQgYXMgYW55LCB0aGlzKS53YWl0KClcbiAgICAgICAgICAgICkpXG4gICAgICAgIClcblxuICAgICAgICAvLyBzb3J0IHRoZSBncm91cHMgYnkgeCBjb29yZGluYXRlcywgc28gdGhlIGxlZnRtb3N0IGlzIGFsd2F5cyBhdCBpbmRleCAwXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBncm91cHMubGVuZ3RoIC0gaSAtIDE7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmICgoYXdhaXQgZ3JvdXBzW2pdLmVsZW0uZ2V0TG9jYXRpb24oJ3gnKSkgPiAoYXdhaXQgZ3JvdXBzW2ogKyAxXS5lbGVtLmdldExvY2F0aW9uKCd4JykpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBncm91cHNbal1cbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzW2pdID0gZ3JvdXBzW2ogKyAxXVxuICAgICAgICAgICAgICAgICAgICBncm91cHNbaiArIDFdID0gdGVtcFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JvdXBzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYW4gZWRpdG9yIGdyb3VwIHdpdGggYSBnaXZlbiBpbmRleCAoY291bnRpbmcgZnJvbSBsZWZ0IHRvIHJpZ2h0KVxuICAgICAqIEBwYXJhbSBpbmRleCB6ZXJvIGJhc2VkIGluZGV4IG9mIHRoZSBlZGl0b3IgZ3JvdXAgKGxlZnRtb3N0IGdyb3VwIGhhcyBpbmRleCAwKVxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIGFuIEVkaXRvckdyb3VwIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIGdldEVkaXRvckdyb3VwIChpbmRleDogbnVtYmVyKTogUHJvbWlzZTxFZGl0b3JHcm91cD4ge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0RWRpdG9yR3JvdXBzKCkpW2luZGV4XVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBlZGl0b3IgYWN0aW9ucyBvZiBhIHNlbGVjdCBlZGl0b3IgZ3JvdXBcbiAgICAgKiBAcGFyYW0gZ3JvdXBJbmRleCB6ZXJvIGJhc2VkIGluZGV4IG9mIHRoZSBlZGl0b3IgZ3JvdXAgKGxlZnRtb3N0IGdyb3VwIGhhcyBpbmRleCAwKSwgZGVmYXVsdCAwXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gbGlzdCBvZiBXZWJFbGVtZW50IG9iamVjdHNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBY3Rpb25zIChncm91cEluZGV4ID0gMCkge1xuICAgICAgICBjb25zdCBncm91cCA9IGF3YWl0IHRoaXMuZ2V0RWRpdG9yR3JvdXAoZ3JvdXBJbmRleClcbiAgICAgICAgcmV0dXJuIGdyb3VwLmdldEFjdGlvbnMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBlZGl0b3IgYWN0aW9uIG9mIGEgc2VsZWN0IGVkaXRvciBncm91cCwgc2VhcmNoIGJ5IHRpdGxlXG4gICAgICogQHBhcmFtIGdyb3VwSW5kZXggemVybyBiYXNlZCBpbmRleCBvZiB0aGUgZWRpdG9yIGdyb3VwIChsZWZ0bW9zdCBncm91cCBoYXMgaW5kZXggMCksIGRlZmF1bHQgMFxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIFdlYkVsZW1lbnQgb2JqZWN0IGlmIGZvdW5kLCB1bmRlZmluZWQgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWN0aW9uICh0aXRsZTogc3RyaW5nLCBncm91cEluZGV4ID0gMCkge1xuICAgICAgICBjb25zdCBncm91cCA9IGF3YWl0IHRoaXMuZ2V0RWRpdG9yR3JvdXAoZ3JvdXBJbmRleClcbiAgICAgICAgcmV0dXJuIGdyb3VwLmdldEFjdGlvbih0aXRsZSlcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRWRpdG9yR3JvdXAgZXh0ZW5kcyBJUGFnZURlY29yYXRvcjx0eXBlb2YgRWRpdG9yVmlld0xvY2F0b3JzPiB7fVxuLyoqXG4gKiBQYWdlIG9iamVjdCByZXByZXNlbnRpbmcgYW4gZWRpdG9yIGdyb3VwXG4gKlxuICogQGNhdGVnb3J5IEVkaXRvclxuICovXG5AUGFnZURlY29yYXRvcihFZGl0b3JWaWV3TG9jYXRvcnMpXG5leHBvcnQgY2xhc3MgRWRpdG9yR3JvdXAgZXh0ZW5kcyBCYXNlUGFnZTx0eXBlb2YgRWRpdG9yVmlld0xvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdFZGl0b3JWaWV3JyBhcyBjb25zdFxuXG4gICAgY29uc3RydWN0b3IgKFxuICAgICAgICBsb2NhdG9yczogVlNDb2RlTG9jYXRvck1hcCxcbiAgICAgICAgZWxlbWVudDogQ2hhaW5hYmxlUHJvbWlzZUVsZW1lbnQ8V2ViZHJpdmVySU8uRWxlbWVudD4sXG4gICAgICAgIHB1YmxpYyB2aWV3ID0gbmV3IEVkaXRvclZpZXcobG9jYXRvcnMpXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGxvY2F0b3JzLCBlbGVtZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3aXRjaCB0byBhbiBlZGl0b3IgdGFiIHdpdGggdGhlIGdpdmVuIHRpdGxlXG4gICAgICogQHBhcmFtIHRpdGxlIHRpdGxlIG9mIHRoZSB0YWJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBFZGl0b3Igb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgb3BlbkVkaXRvciAodGl0bGU6IHN0cmluZyk6IFByb21pc2U8U2V0dGluZ3NFZGl0b3IgfCBEaWZmRWRpdG9yIHwgVGV4dEVkaXRvcj4ge1xuICAgICAgICBjb25zdCB0YWIgPSBhd2FpdCB0aGlzLmdldFRhYkJ5VGl0bGUodGl0bGUpXG4gICAgICAgIGF3YWl0IHRhYi5zZWxlY3QoKVxuXG4gICAgICAgIGlmIChhd2FpdCB0aGlzLnNldHRpbmdzRWRpdG9yJC5pc0V4aXN0aW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2V0dGluZ3NFZGl0b3IoXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdG9yTWFwLFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICkud2FpdCgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXdhaXQgdGhpcy5kaWZmRWRpdG9yJC5pc0V4aXN0aW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGlmZkVkaXRvcihcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0b3JNYXAsXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdG9yTWFwLkVkaXRvci5lbGVtIGFzIHN0cmluZyxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApLndhaXQoKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0RWRpdG9yKFxuICAgICAgICAgICAgdGhpcy5sb2NhdG9yTWFwLFxuICAgICAgICAgICAgdGhpcy5sb2NhdG9yTWFwLkVkaXRvci5lbGVtIGFzIHN0cmluZyxcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgKS53YWl0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSBhbiBlZGl0b3IgdGFiIHdpdGggdGhlIGdpdmVuIHRpdGxlXG4gICAgICogQHBhcmFtIHRpdGxlIHRpdGxlIG9mIHRoZSB0YWJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSB0YWIncyBjbG9zZSBidXR0b24gaXMgcHJlc3NlZFxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlRWRpdG9yICh0aXRsZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHRhYiA9IGF3YWl0IHRoaXMuZ2V0VGFiQnlUaXRsZSh0aXRsZSlcbiAgICAgICAgYXdhaXQgdGFiLmVsZW0ubW92ZVRvKClcbiAgICAgICAgY29uc3QgY2xvc2VCdXR0b24gPSBhd2FpdCB0YWIuZWxlbS4kKHRoaXMubG9jYXRvcnMuY2xvc2VUYWIpXG4gICAgICAgIGF3YWl0IGNsb3NlQnV0dG9uLmNsaWNrKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSBhbGwgb3BlbiBlZGl0b3IgdGFic1xuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIG9uY2UgYWxsIHRhYnMgaGF2ZSBoYWQgdGhlaXIgY2xvc2UgYnV0dG9uIHByZXNzZWRcbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZUFsbEVkaXRvcnMgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBsZXQgdGl0bGVzID0gYXdhaXQgdGhpcy5nZXRPcGVuRWRpdG9yVGl0bGVzKClcbiAgICAgICAgd2hpbGUgKHRpdGxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsb3NlRWRpdG9yKHRpdGxlc1swXSlcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGdyb3VwIHN0aWxsIGV4aXN0c1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZWxlbS5nZXRUYWdOYW1lKClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aXRsZXMgPSBhd2FpdCB0aGlzLmdldE9wZW5FZGl0b3JUaXRsZXMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYWxsIG9wZW4gZWRpdG9yIHRhYiB0aXRsZXMgaW4gYW4gYXJyYXlcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhcnJheSBvZiBlZGl0b3IgdGl0bGVzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0T3BlbkVkaXRvclRpdGxlcyAoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgICAgICBjb25zdCB0YWJzID0gYXdhaXQgdGhpcy50YWIkJFxuICAgICAgICBjb25zdCB0aXRsZXMgPSBbXVxuICAgICAgICBmb3IgKGNvbnN0IHRhYiBvZiB0YWJzKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgY29uc3QgdGl0bGUgPSBhd2FpdCBuZXcgRWRpdG9yVGFiKHRoaXMubG9jYXRvck1hcCwgdGFiIGFzIGFueSwgdGhpcy52aWV3KS5nZXRUaXRsZSgpXG4gICAgICAgICAgICB0aXRsZXMucHVzaCh0aXRsZSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGl0bGVzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYW4gZWRpdG9yIHRhYiBieSB0aXRsZVxuICAgICAqIEBwYXJhbSB0aXRsZSB0aXRsZSBvZiB0aGUgdGFiXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gRWRpdG9yVGFiIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIGdldFRhYkJ5VGl0bGUgKHRpdGxlOiBzdHJpbmcpOiBQcm9taXNlPEVkaXRvclRhYj4ge1xuICAgICAgICBjb25zdCB0YWJzID0gYXdhaXQgdGhpcy50YWIkJFxuICAgICAgICBjb25zdCBhdmFpbGFibGVMYWJlbHMgPSBuZXcgU2V0KClcbiAgICAgICAgZm9yIChjb25zdCB0YWIgb2YgdGFicykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvclRhYiA9IG5ldyBFZGl0b3JUYWIodGhpcy5sb2NhdG9yTWFwLCB0YWIgYXMgYW55LCB0aGlzLnZpZXcpXG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGF3YWl0IGVkaXRvclRhYi5nZXRUaXRsZSgpXG4gICAgICAgICAgICBhdmFpbGFibGVMYWJlbHMuYWRkKGxhYmVsKVxuICAgICAgICAgICAgaWYgKGxhYmVsID09PSB0aXRsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlZGl0b3JUYWJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgTm8gZWRpdG9yIHdpdGggdGl0bGUgJyR7dGl0bGV9JyBmb3VuZCwgYFxuICAgICAgICAgICAgKyBgYXZhaWxhYmxlIGVkaXRvciB3ZXJlOiAke1suLi5hdmFpbGFibGVMYWJlbHNdLmpvaW4oJywgJyl9YFxuICAgICAgICApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYWxsIG9wZW4gZWRpdG9yIHRhYnNcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byBFZGl0b3JUYWIgbGlzdFxuICAgICAqL1xuICAgIGFzeW5jIGdldE9wZW5UYWJzICgpOiBQcm9taXNlPEVkaXRvclRhYltdPiB7XG4gICAgICAgIGNvbnN0IHRhYnMgPSBhd2FpdCB0aGlzLnRhYiQkXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIHRhYnMubWFwKGFzeW5jICh0YWIpID0+IChcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgICAgIG5ldyBFZGl0b3JUYWIodGhpcy5sb2NhdG9yTWFwLCB0YWIgYXMgYW55LCB0aGlzLnZpZXcpLndhaXQoKVxuICAgICAgICAgICAgKSlcbiAgICAgICAgKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBhY3RpdmUgZWRpdG9yIHRhYlxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIEVkaXRvclRhYiBvYmplY3QsIHVuZGVmaW5lZCBpZiBubyB0YWIgaXMgYWN0aXZlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWN0aXZlVGFiICgpOiBQcm9taXNlPEVkaXRvclRhYiB8IHVuZGVmaW5lZD4ge1xuICAgICAgICBjb25zdCB0YWJzID0gYXdhaXQgdGhpcy5nZXRPcGVuVGFicygpXG4gICAgICAgIGNvbnN0IGtsYXNzZXMgPSBhd2FpdCBQcm9taXNlLmFsbCh0YWJzLm1hcChhc3luYyAodGFiKSA9PiB0YWIuZWxlbS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpKVxuICAgICAgICBjb25zdCBpbmRleCA9IGtsYXNzZXMuZmluZEluZGV4KChrbGFzcykgPT4ga2xhc3MuaW5kZXhPZignYWN0aXZlJykgPiAtMSlcblxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhYnNbaW5kZXhdXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBlZGl0b3IgYWN0aW9uIGJ1dHRvbnMgYXMgV2ViRWxlbWVudHNcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byBsaXN0IG9mIFdlYkVsZW1lbnQgb2JqZWN0c1xuICAgICAqL1xuICAgIGFzeW5jIGdldEFjdGlvbnMgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb25Db250YWluZXIkLiQkKHRoaXMubG9jYXRvcnMuYWN0aW9uSXRlbSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuIGVkaXRvciBhY3Rpb24gYnV0dG9uIGJ5IHRpdGxlXG4gICAgICogQHBhcmFtIHRpdGxlIHRpdGxlIG9mIHRoZSBidXR0b25cbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byBXZWJFbGVtZW50IHJlcHJlc2VudGluZyB0aGUgYnV0dG9uIGlmIGZvdW5kLCB1bmRlZmluZWQgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWN0aW9uICh0aXRsZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSBhd2FpdCB0aGlzLmdldEFjdGlvbnMoKVxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKGF3YWl0IGl0ZW0uZ2V0QXR0cmlidXRlKCd0aXRsZScpID09PSB0aXRsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFZGl0b3JUYWIgZXh0ZW5kcyBJUGFnZURlY29yYXRvcjx0eXBlb2YgRWRpdG9yTG9jYXRvcnNPYmo+IHt9XG4vKipcbiAqIFBhZ2Ugb2JqZWN0IGZvciBlZGl0b3IgdmlldyB0YWJcbiAqXG4gKiBAY2F0ZWdvcnkgRWRpdG9yXG4gKi9cbkBQYWdlRGVjb3JhdG9yKEVkaXRvckxvY2F0b3JzT2JqKVxuZXhwb3J0IGNsYXNzIEVkaXRvclRhYiBleHRlbmRzIEVsZW1lbnRXaXRoQ29udGV4dE1lbnU8dHlwZW9mIEVkaXRvckxvY2F0b3JzT2JqPiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdFZGl0b3InIGFzIGNvbnN0XG5cbiAgICBjb25zdHJ1Y3RvciAoXG4gICAgICAgIGxvY2F0b3JzOiBWU0NvZGVMb2NhdG9yTWFwLFxuICAgICAgICBlbGVtZW50OiBDaGFpbmFibGVQcm9taXNlRWxlbWVudDxXZWJkcml2ZXJJTy5FbGVtZW50PixcbiAgICAgICAgcHVibGljIHZpZXc6IEVkaXRvclZpZXdcbiAgICApIHtcbiAgICAgICAgc3VwZXIobG9jYXRvcnMsIGVsZW1lbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0YWIgdGl0bGUgYXMgc3RyaW5nXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VGl0bGUgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlJC5nZXRUZXh0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgKGNsaWNrKSB0aGUgdGFiXG4gICAgICovXG4gICAgYXN5bmMgc2VsZWN0ICgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbGVtLmNsaWNrKClcbiAgICB9XG59XG4iXX0=