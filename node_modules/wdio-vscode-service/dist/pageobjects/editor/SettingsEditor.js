var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Editor } from './Editor.js';
import { EditorView } from '../index.js';
import { PageDecorator, BasePage, sleep } from '../utils.js';
import { SettingsEditor as SettingsEditorLocators } from '../../locators/1.73.0.js';
/**
 * Page object representing the internal VSCode settings editor
 *
 * @category Editor
 */
export let SettingsEditor = class SettingsEditor extends Editor {
    constructor(locators, view) {
        super(locators, view?.elem);
        /**
         * @private
         */
        this.locatorKey = 'SettingsEditor';
        this.view = view || new EditorView(this.locatorMap);
    }
    /**
     * Search for a setting with a particular title and category.
     * Returns an appropriate Setting object if the label is found,
     * undefined otherwise.
     *
     * If your setting has nested categories (i.e `example.general.test`),
     * pass in each category as a separate string.
     *
     * @param title title of the setting
     * @param categories category of the setting
     * @returns Promise resolving to a Setting object if found, undefined otherwise
     */
    async findSetting(title, ...categories) {
        const category = categories.join(' â€º ');
        const searchBox = await this.elem.$(this.locatorMap.Editor.inputArea);
        await searchBox.setValue(`${category}: ${title}`);
        const count = await this.itemCount$;
        let textCount = await count.getText();
        await browser.waitUntil(async () => {
            await sleep(1500);
            const text = await count.getText();
            if (text !== textCount) {
                textCount = text;
                return false;
            }
            return true;
        });
        let setting;
        const items = await this.itemRow$$;
        for (const item of items) {
            try {
                return await (await this.createSetting(item, title, category)).wait();
            }
            catch (err) {
                // ignore
            }
        }
        return setting;
    }
    /**
     * Switch between settings perspectives
     * Works only if your vscode instance has both user and workspace settings available
     *
     * @param perspective User or Workspace
     * @returns Promise that resolves when the appropriate button is clicked
     */
    async switchToPerspective(perspective) {
        await this.header$
            .$(this.locators.tabs)
            .$(this.locators.actions)
            .$(this.locators.action(perspective))
            .click();
    }
    /**
     * Context menu is disabled in this editor, throw an error
     */
    openContextMenu() {
        throw new Error('Operation not supported');
    }
    async createSetting(element, title, category) {
        if (!await element.$(this.locators.settingConstructor(title, category)).isExisting()) {
            throw new Error('Setting not found');
        }
        // try a combo setting
        if (await element.$(this.locators.comboSetting).isExisting()) {
            return new ComboSetting(this.locatorMap, title, category, this);
        }
        // try text setting
        if (await element.$(this.locators.textSetting).isExisting()) {
            return new TextSetting(this.locatorMap, title, category, this);
        }
        // try checkbox setting
        if (await element.$(this.locators.checkboxSetting).isExisting()) {
            return new CheckboxSetting(this.locatorMap, title, category, this);
        }
        // try link setting
        if (await element.$(this.locators.linkButton).isExisting()) {
            return new LinkSetting(this.locatorMap, title, category, this);
        }
        throw new Error('Setting type not supported');
    }
};
SettingsEditor = __decorate([
    PageDecorator(SettingsEditorLocators)
], SettingsEditor);
/**
 * Abstract item representing a Setting with title, description and
 * an input element (combo/textbox/checkbox/link)
 *
 * @category Editor
 */
export class Setting extends BasePage {
    constructor(locators, title, category, settings) {
        super(locators, locators.SettingsEditor.settingConstructor(title, category));
        this.settings = settings;
        this.title = title;
        this.category = category;
    }
    /**
     * Get the category of the setting
     * All settings are labeled as Category: Title
     */
    getCategory() {
        return this.category;
    }
    /**
     * Get description of the setting
     * @returns Promise resolving to setting description
     */
    async getDescription() {
        return this.settingDesctiption$.getText();
    }
    /**
     * Get title of the setting
     */
    getTitle() {
        return this.title;
    }
}
/**
 * Setting with a combo box
 *
 * @category Editor
 */
export let ComboSetting = class ComboSetting extends Setting {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'SettingsEditor';
    }
    getValue() {
        return this.comboSetting$.getAttribute('title');
    }
    async setValue(value) {
        const rows = await this.getOptions();
        for (let i = 0; i < rows.length; i += 1) {
            if ((await rows[i].getAttribute('class')).indexOf('disabled') < 0) {
                const text = await rows[i].$(this.locators.comboOption).getText();
                if (value === text) {
                    await rows[i].click();
                    return;
                }
            }
        }
    }
    /**
     * Get the labels of all options from the combo
     * @returns Promise resolving to array of string values
     */
    async getValues() {
        const values = [];
        const rows = await this.getOptions();
        for (const row of rows) {
            values.push(await row.$(this.locators.comboOption).getText());
        }
        return values;
    }
    async getOptions() {
        const menu = await this.openCombo();
        return menu.$$(this.locators.itemRow);
    }
    async openCombo() {
        const combo = await this.comboSetting$;
        const workbench = await browser.$(this.locatorMap.Workbench.elem);
        const menus = await workbench.$$(this.locatorMap.ContextMenu.contextView);
        let menu;
        if (menus.length < 1) {
            await combo.click();
            menu = await workbench.$(this.locatorMap.ContextMenu.contextView);
            return menu;
        }
        if (await menus[0].isDisplayed()) {
            await combo.click();
            // eslint-disable-next-line wdio/no-pause
            await browser.pause(200);
        }
        await combo.click();
        menu = await workbench.$(this.locatorMap.ContextMenu.contextView);
        return menu;
    }
};
ComboSetting = __decorate([
    PageDecorator(SettingsEditorLocators)
], ComboSetting);
/**
 * Setting with a text box input
 *
 * @category Editor
 */
export let TextSetting = class TextSetting extends Setting {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'SettingsEditor';
    }
    async getValue() {
        return this.textSetting$.getAttribute('value');
    }
    async setValue(value) {
        const input = await this.textSetting$;
        await input.setValue(value);
    }
};
TextSetting = __decorate([
    PageDecorator(SettingsEditorLocators)
], TextSetting);
/**
 * Setting with a checkbox
 *
 * @category Editor
 */
export let CheckboxSetting = class CheckboxSetting extends Setting {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'SettingsEditor';
    }
    async getValue() {
        const checked = await this.checkboxSetting$.getAttribute(this.locators.checkboxChecked);
        if (checked === 'true') {
            return true;
        }
        return false;
    }
    async setValue(value) {
        if (await this.getValue() !== value) {
            await this.checkboxSetting$.click();
        }
    }
};
CheckboxSetting = __decorate([
    PageDecorator(SettingsEditorLocators)
], CheckboxSetting);
/**
 * Setting with no value, with a link to settings.json instead
 *
 * @category Editor
 */
export let LinkSetting = class LinkSetting extends Setting {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'SettingsEditor';
    }
    getValue() {
        throw new Error('Method getValue is not available for LinkSetting');
    }
    setValue() {
        throw new Error('Method setValue is not available for LinkSetting');
    }
    /**
     * Open the link that leads to the value in settings.json
     * @returns Promise resolving when the link has been clicked
     */
    async openLink() {
        await this.linkButton$.click();
    }
};
LinkSetting = __decorate([
    PageDecorator(SettingsEditorLocators)
], LinkSetting);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2V0dGluZ3NFZGl0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcGFnZW9iamVjdHMvZWRpdG9yL1NldHRpbmdzRWRpdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQWtCLE1BQU0sYUFBYSxDQUFBO0FBRXBELE9BQU8sRUFBRSxVQUFVLEVBQWUsTUFBTSxhQUFhLENBQUE7QUFFckQsT0FBTyxFQUNILGFBQWEsRUFBa0IsUUFBUSxFQUFvQixLQUFLLEVBQ25FLE1BQU0sYUFBYSxDQUFBO0FBQ3BCLE9BQU8sRUFBRSxjQUFjLElBQUksc0JBQXNCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQTtBQUduRjs7OztHQUlHO0FBRUksV0FBTSxjQUFjLEdBQXBCLE1BQU0sY0FBZSxTQUFRLE1BQXNCO0lBT3RELFlBQ0ksUUFBMEIsRUFDMUIsSUFBK0I7UUFFL0IsS0FBSyxDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUE7UUFWL0I7O1dBRUc7UUFDSSxlQUFVLEdBQUcsZ0JBQXlCLENBQUE7UUFRekMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLElBQUksSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFBO0lBQ3ZELENBQUM7SUFFRDs7Ozs7Ozs7Ozs7T0FXRztJQUNILEtBQUssQ0FBQyxXQUFXLENBQUUsS0FBYSxFQUFFLEdBQUcsVUFBb0I7UUFDckQsTUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQTtRQUN2QyxNQUFNLFNBQVMsR0FBRyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFNBQW1CLENBQUMsQ0FBQTtRQUMvRSxNQUFNLFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxRQUFRLEtBQUssS0FBSyxFQUFFLENBQUMsQ0FB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QUFDO0NBQ0osQ0FBQTtBQW5CWSxlQUFlO0lBRDNCLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBQztHQUN6QixlQUFlLENBbUIzQjtBQUdEOzs7O0dBSUc7QUFFSSxXQUFNLFdBQVcsR0FBakIsTUFBTSxXQUFZLFNBQVEsT0FBTztJQUFqQzs7UUFDSDs7V0FFRztRQUNJLGVBQVUsR0FBRyxnQkFBeUIsQ0FBQTtJQWlCakQsQ0FBQztJQWZHLFFBQVE7UUFDSixNQUFNLElBQUksS0FBSyxDQUFDLGtEQUFrRCxDQUFDLENBQUE7SUFDdkUsQ0FBQztJQUVELFFBQVE7UUFDSixNQUFNLElBQUksS0FBSyxDQUFDLGtEQUFrRCxDQUFDLENBQUE7SUFDdkUsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxRQUFRO1FBQ1YsTUFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxDQUFBO0lBQ2xDLENBQUM7Q0FDSixDQUFBO0FBckJZLFdBQVc7SUFEdkIsYUFBYSxDQUFDLHNCQUFzQixDQUFDO0dBQ3pCLFdBQVcsQ0FxQnZCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWRpdG9yLCBFZGl0b3JMb2NhdG9ycyB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgQ29udGV4dE1lbnUgfSBmcm9tICcuLi9tZW51L0NvbnRleHRNZW51LmpzJ1xuaW1wb3J0IHsgRWRpdG9yVmlldywgRWRpdG9yR3JvdXAgfSBmcm9tICcuLi9pbmRleC5qcydcblxuaW1wb3J0IHtcbiAgICBQYWdlRGVjb3JhdG9yLCBJUGFnZURlY29yYXRvciwgQmFzZVBhZ2UsIFZTQ29kZUxvY2F0b3JNYXAsIHNsZWVwXG59IGZyb20gJy4uL3V0aWxzLmpzJ1xuaW1wb3J0IHsgU2V0dGluZ3NFZGl0b3IgYXMgU2V0dGluZ3NFZGl0b3JMb2NhdG9ycyB9IGZyb20gJy4uLy4uL2xvY2F0b3JzLzEuNzMuMC5qcydcblxuZXhwb3J0IGludGVyZmFjZSBTZXR0aW5nc0VkaXRvciBleHRlbmRzIElQYWdlRGVjb3JhdG9yPEVkaXRvckxvY2F0b3JzPiB7fVxuLyoqXG4gKiBQYWdlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGludGVybmFsIFZTQ29kZSBzZXR0aW5ncyBlZGl0b3JcbiAqXG4gKiBAY2F0ZWdvcnkgRWRpdG9yXG4gKi9cbkBQYWdlRGVjb3JhdG9yKFNldHRpbmdzRWRpdG9yTG9jYXRvcnMpXG5leHBvcnQgY2xhc3MgU2V0dGluZ3NFZGl0b3IgZXh0ZW5kcyBFZGl0b3I8RWRpdG9yTG9jYXRvcnM+IHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBsb2NhdG9yS2V5ID0gJ1NldHRpbmdzRWRpdG9yJyBhcyBjb25zdFxuICAgIHB1YmxpYyB2aWV3OiBFZGl0b3JWaWV3IHwgRWRpdG9yR3JvdXBcblxuICAgIGNvbnN0cnVjdG9yIChcbiAgICAgICAgbG9jYXRvcnM6IFZTQ29kZUxvY2F0b3JNYXAsXG4gICAgICAgIHZpZXc/OiBFZGl0b3JWaWV3IHwgRWRpdG9yR3JvdXBcbiAgICApIHtcbiAgICAgICAgc3VwZXIobG9jYXRvcnMsIHZpZXc/LmVsZW0pXG4gICAgICAgIHRoaXMudmlldyA9IHZpZXcgfHwgbmV3IEVkaXRvclZpZXcodGhpcy5sb2NhdG9yTWFwKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBmb3IgYSBzZXR0aW5nIHdpdGggYSBwYXJ0aWN1bGFyIHRpdGxlIGFuZCBjYXRlZ29yeS5cbiAgICAgKiBSZXR1cm5zIGFuIGFwcHJvcHJpYXRlIFNldHRpbmcgb2JqZWN0IGlmIHRoZSBsYWJlbCBpcyBmb3VuZCxcbiAgICAgKiB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogSWYgeW91ciBzZXR0aW5nIGhhcyBuZXN0ZWQgY2F0ZWdvcmllcyAoaS5lIGBleGFtcGxlLmdlbmVyYWwudGVzdGApLFxuICAgICAqIHBhc3MgaW4gZWFjaCBjYXRlZ29yeSBhcyBhIHNlcGFyYXRlIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aXRsZSB0aXRsZSBvZiB0aGUgc2V0dGluZ1xuICAgICAqIEBwYXJhbSBjYXRlZ29yaWVzIGNhdGVnb3J5IG9mIHRoZSBzZXR0aW5nXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYSBTZXR0aW5nIG9iamVjdCBpZiBmb3VuZCwgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGFzeW5jIGZpbmRTZXR0aW5nICh0aXRsZTogc3RyaW5nLCAuLi5jYXRlZ29yaWVzOiBzdHJpbmdbXSk6IFByb21pc2U8U2V0dGluZz4ge1xuICAgICAgICBjb25zdCBjYXRlZ29yeSA9IGNhdGVnb3JpZXMuam9pbignIOKAuiAnKVxuICAgICAgICBjb25zdCBzZWFyY2hCb3ggPSBhd2FpdCB0aGlzLmVsZW0uJCh0aGlzLmxvY2F0b3JNYXAuRWRpdG9yLmlucHV0QXJlYSBhcyBzdHJpbmcpXG4gICAgICAgIGF3YWl0IHNlYXJjaEJveC5zZXRWYWx1ZShgJHtjYXRlZ29yeX06ICR7dGl0bGV9YClcblxuICAgICAgICBjb25zdCBjb3VudCA9IGF3YWl0IHRoaXMuaXRlbUNvdW50JFxuICAgICAgICBsZXQgdGV4dENvdW50ID0gYXdhaXQgY291bnQuZ2V0VGV4dCgpXG5cbiAgICAgICAgYXdhaXQgYnJvd3Nlci53YWl0VW50aWwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAoMTUwMClcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCBjb3VudC5nZXRUZXh0KClcbiAgICAgICAgICAgIGlmICh0ZXh0ICE9PSB0ZXh0Q291bnQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0Q291bnQgPSB0ZXh0XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9KVxuXG4gICAgICAgIGxldCBzZXR0aW5nITogU2V0dGluZ1xuICAgICAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHRoaXMuaXRlbVJvdyQkXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgKGF3YWl0IHRoaXMuY3JlYXRlU2V0dGluZyhpdGVtLCB0aXRsZSwgY2F0ZWdvcnkpKS53YWl0KClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXR0aW5nXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3dpdGNoIGJldHdlZW4gc2V0dGluZ3MgcGVyc3BlY3RpdmVzXG4gICAgICogV29ya3Mgb25seSBpZiB5b3VyIHZzY29kZSBpbnN0YW5jZSBoYXMgYm90aCB1c2VyIGFuZCB3b3Jrc3BhY2Ugc2V0dGluZ3MgYXZhaWxhYmxlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGVyc3BlY3RpdmUgVXNlciBvciBXb3Jrc3BhY2VcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgYXBwcm9wcmlhdGUgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgKi9cbiAgICBhc3luYyBzd2l0Y2hUb1BlcnNwZWN0aXZlIChwZXJzcGVjdGl2ZTogJ1VzZXInIHwgJ1dvcmtzcGFjZScpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5oZWFkZXIkXG4gICAgICAgICAgICAuJCh0aGlzLmxvY2F0b3JzLnRhYnMpXG4gICAgICAgICAgICAuJCh0aGlzLmxvY2F0b3JzLmFjdGlvbnMpXG4gICAgICAgICAgICAuJCh0aGlzLmxvY2F0b3JzLmFjdGlvbihwZXJzcGVjdGl2ZSkpXG4gICAgICAgICAgICAuY2xpY2soKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnRleHQgbWVudSBpcyBkaXNhYmxlZCBpbiB0aGlzIGVkaXRvciwgdGhyb3cgYW4gZXJyb3JcbiAgICAgKi9cbiAgICBvcGVuQ29udGV4dE1lbnUgKCk6IFByb21pc2U8Q29udGV4dE1lbnU+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcGVyYXRpb24gbm90IHN1cHBvcnRlZCcpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBjcmVhdGVTZXR0aW5nIChlbGVtZW50OiBXZWJkcml2ZXJJTy5FbGVtZW50LCB0aXRsZTogc3RyaW5nLCBjYXRlZ29yeTogc3RyaW5nKTogUHJvbWlzZTxTZXR0aW5nPiB7XG4gICAgICAgIGlmICghYXdhaXQgZWxlbWVudC4kKHRoaXMubG9jYXRvcnMuc2V0dGluZ0NvbnN0cnVjdG9yKHRpdGxlLCBjYXRlZ29yeSkpLmlzRXhpc3RpbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXR0aW5nIG5vdCBmb3VuZCcpXG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cnkgYSBjb21ibyBzZXR0aW5nXG4gICAgICAgIGlmIChhd2FpdCBlbGVtZW50LiQodGhpcy5sb2NhdG9ycy5jb21ib1NldHRpbmcpLmlzRXhpc3RpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21ib1NldHRpbmcodGhpcy5sb2NhdG9yTWFwLCB0aXRsZSwgY2F0ZWdvcnksIHRoaXMpXG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cnkgdGV4dCBzZXR0aW5nXG4gICAgICAgIGlmIChhd2FpdCBlbGVtZW50LiQodGhpcy5sb2NhdG9ycy50ZXh0U2V0dGluZykuaXNFeGlzdGluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRTZXR0aW5nKHRoaXMubG9jYXRvck1hcCwgdGl0bGUsIGNhdGVnb3J5LCB0aGlzKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IGNoZWNrYm94IHNldHRpbmdcbiAgICAgICAgaWYgKGF3YWl0IGVsZW1lbnQuJCh0aGlzLmxvY2F0b3JzLmNoZWNrYm94U2V0dGluZykuaXNFeGlzdGluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoZWNrYm94U2V0dGluZyh0aGlzLmxvY2F0b3JNYXAsIHRpdGxlLCBjYXRlZ29yeSwgdGhpcylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSBsaW5rIHNldHRpbmdcbiAgICAgICAgaWYgKGF3YWl0IGVsZW1lbnQuJCh0aGlzLmxvY2F0b3JzLmxpbmtCdXR0b24pLmlzRXhpc3RpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5rU2V0dGluZyh0aGlzLmxvY2F0b3JNYXAsIHRpdGxlLCBjYXRlZ29yeSwgdGhpcylcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2V0dGluZyB0eXBlIG5vdCBzdXBwb3J0ZWQnKVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXR0aW5nIGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8dHlwZW9mIFNldHRpbmdzRWRpdG9yTG9jYXRvcnM+IHt9XG4vKipcbiAqIEFic3RyYWN0IGl0ZW0gcmVwcmVzZW50aW5nIGEgU2V0dGluZyB3aXRoIHRpdGxlLCBkZXNjcmlwdGlvbiBhbmRcbiAqIGFuIGlucHV0IGVsZW1lbnQgKGNvbWJvL3RleHRib3gvY2hlY2tib3gvbGluaylcbiAqXG4gKiBAY2F0ZWdvcnkgRWRpdG9yXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTZXR0aW5nIGV4dGVuZHMgQmFzZVBhZ2U8dHlwZW9mIFNldHRpbmdzRWRpdG9yTG9jYXRvcnM+IHtcbiAgICBwcml2YXRlIHRpdGxlOiBzdHJpbmdcbiAgICBwcml2YXRlIGNhdGVnb3J5OiBzdHJpbmdcblxuICAgIGNvbnN0cnVjdG9yIChcbiAgICAgICAgbG9jYXRvcnM6IFZTQ29kZUxvY2F0b3JNYXAsXG4gICAgICAgIHRpdGxlOiBzdHJpbmcsXG4gICAgICAgIGNhdGVnb3J5OiBzdHJpbmcsXG4gICAgICAgIHB1YmxpYyBzZXR0aW5nczogU2V0dGluZ3NFZGl0b3JcbiAgICApIHtcbiAgICAgICAgc3VwZXIobG9jYXRvcnMsIChsb2NhdG9ycy5TZXR0aW5nc0VkaXRvci5zZXR0aW5nQ29uc3RydWN0b3IgYXMgRnVuY3Rpb24pKHRpdGxlLCBjYXRlZ29yeSkgYXMgc3RyaW5nKVxuICAgICAgICB0aGlzLnRpdGxlID0gdGl0bGVcbiAgICAgICAgdGhpcy5jYXRlZ29yeSA9IGNhdGVnb3J5XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgc2V0dGluZyBiYXNlZCBvbiBpdHMgaW5wdXQgdHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBzZXR0aW5nXG4gICAgICovXG4gICAgYWJzdHJhY3QgZ2V0VmFsdWUgKCk6IFByb21pc2U8c3RyaW5nIHwgYm9vbGVhbj5cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIHNldHRpbmcgYmFzZWQgb24gaXRzIGlucHV0IHR5cGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBib29sZWFuIGZvciBjaGVja2JveGVzLCBzdHJpbmcgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgYWJzdHJhY3Qgc2V0VmFsdWUgKHZhbHVlOiBzdHJpbmcgfCBib29sZWFuKTogUHJvbWlzZTx2b2lkPlxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjYXRlZ29yeSBvZiB0aGUgc2V0dGluZ1xuICAgICAqIEFsbCBzZXR0aW5ncyBhcmUgbGFiZWxlZCBhcyBDYXRlZ29yeTogVGl0bGVcbiAgICAgKi9cbiAgICBnZXRDYXRlZ29yeSAoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2F0ZWdvcnlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZGVzY3JpcHRpb24gb2YgdGhlIHNldHRpbmdcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBzZXR0aW5nIGRlc2NyaXB0aW9uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVzY3JpcHRpb24gKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdEZXNjdGlwdGlvbiQuZ2V0VGV4dCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRpdGxlIG9mIHRoZSBzZXR0aW5nXG4gICAgICovXG4gICAgZ2V0VGl0bGUgKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlXG4gICAgfVxufVxuXG4vKipcbiAqIFNldHRpbmcgd2l0aCBhIGNvbWJvIGJveFxuICpcbiAqIEBjYXRlZ29yeSBFZGl0b3JcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoU2V0dGluZ3NFZGl0b3JMb2NhdG9ycylcbmV4cG9ydCBjbGFzcyBDb21ib1NldHRpbmcgZXh0ZW5kcyBTZXR0aW5nIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBsb2NhdG9yS2V5ID0gJ1NldHRpbmdzRWRpdG9yJyBhcyBjb25zdFxuXG4gICAgZ2V0VmFsdWUgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbWJvU2V0dGluZyQuZ2V0QXR0cmlidXRlKCd0aXRsZScpXG4gICAgfVxuXG4gICAgYXN5bmMgc2V0VmFsdWUgKHZhbHVlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3Qgcm93cyA9IGF3YWl0IHRoaXMuZ2V0T3B0aW9ucygpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKChhd2FpdCByb3dzW2ldLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSkuaW5kZXhPZignZGlzYWJsZWQnKSA8IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcm93c1tpXS4kKHRoaXMubG9jYXRvcnMuY29tYm9PcHRpb24pLmdldFRleHQoKVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCByb3dzW2ldLmNsaWNrKClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsYWJlbHMgb2YgYWxsIG9wdGlvbnMgZnJvbSB0aGUgY29tYm9cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhcnJheSBvZiBzdHJpbmcgdmFsdWVzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VmFsdWVzICgpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdXG4gICAgICAgIGNvbnN0IHJvd3MgPSBhd2FpdCB0aGlzLmdldE9wdGlvbnMoKVxuXG4gICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGF3YWl0IHJvdy4kKHRoaXMubG9jYXRvcnMuY29tYm9PcHRpb24pLmdldFRleHQoKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRPcHRpb25zICgpIHtcbiAgICAgICAgY29uc3QgbWVudSA9IGF3YWl0IHRoaXMub3BlbkNvbWJvKClcbiAgICAgICAgcmV0dXJuIG1lbnUuJCQodGhpcy5sb2NhdG9ycy5pdGVtUm93KVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgb3BlbkNvbWJvICgpIHtcbiAgICAgICAgY29uc3QgY29tYm8gPSBhd2FpdCB0aGlzLmNvbWJvU2V0dGluZyRcbiAgICAgICAgY29uc3Qgd29ya2JlbmNoID0gYXdhaXQgYnJvd3Nlci4kKHRoaXMubG9jYXRvck1hcC5Xb3JrYmVuY2guZWxlbSBhcyBzdHJpbmcpXG4gICAgICAgIGNvbnN0IG1lbnVzID0gYXdhaXQgd29ya2JlbmNoLiQkKHRoaXMubG9jYXRvck1hcC5Db250ZXh0TWVudS5jb250ZXh0VmlldyBhcyBzdHJpbmcpXG4gICAgICAgIGxldCBtZW51ITogV2ViZHJpdmVySU8uRWxlbWVudFxuXG4gICAgICAgIGlmIChtZW51cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICBhd2FpdCBjb21iby5jbGljaygpXG4gICAgICAgICAgICBtZW51ID0gYXdhaXQgd29ya2JlbmNoLiQodGhpcy5sb2NhdG9yTWFwLkNvbnRleHRNZW51LmNvbnRleHRWaWV3IGFzIHN0cmluZylcbiAgICAgICAgICAgIHJldHVybiBtZW51XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF3YWl0IG1lbnVzWzBdLmlzRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgIGF3YWl0IGNvbWJvLmNsaWNrKClcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB3ZGlvL25vLXBhdXNlXG4gICAgICAgICAgICBhd2FpdCBicm93c2VyLnBhdXNlKDIwMClcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBjb21iby5jbGljaygpXG4gICAgICAgIG1lbnUgPSBhd2FpdCB3b3JrYmVuY2guJCh0aGlzLmxvY2F0b3JNYXAuQ29udGV4dE1lbnUuY29udGV4dFZpZXcgYXMgc3RyaW5nKVxuICAgICAgICByZXR1cm4gbWVudVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBUZXh0U2V0dGluZyBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBTZXR0aW5nc0VkaXRvckxvY2F0b3JzPiB7fVxuLyoqXG4gKiBTZXR0aW5nIHdpdGggYSB0ZXh0IGJveCBpbnB1dFxuICpcbiAqIEBjYXRlZ29yeSBFZGl0b3JcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoU2V0dGluZ3NFZGl0b3JMb2NhdG9ycylcbmV4cG9ydCBjbGFzcyBUZXh0U2V0dGluZyBleHRlbmRzIFNldHRpbmcge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnU2V0dGluZ3NFZGl0b3InIGFzIGNvbnN0XG5cbiAgICBhc3luYyBnZXRWYWx1ZSAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dFNldHRpbmckLmdldEF0dHJpYnV0ZSgndmFsdWUnKVxuICAgIH1cblxuICAgIGFzeW5jIHNldFZhbHVlICh2YWx1ZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gYXdhaXQgdGhpcy50ZXh0U2V0dGluZyRcbiAgICAgICAgYXdhaXQgaW5wdXQuc2V0VmFsdWUodmFsdWUpXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRleHRTZXR0aW5nIGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8dHlwZW9mIFNldHRpbmdzRWRpdG9yTG9jYXRvcnM+IHt9XG4vKipcbiAqIFNldHRpbmcgd2l0aCBhIGNoZWNrYm94XG4gKlxuICogQGNhdGVnb3J5IEVkaXRvclxuICovXG5AUGFnZURlY29yYXRvcihTZXR0aW5nc0VkaXRvckxvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIENoZWNrYm94U2V0dGluZyBleHRlbmRzIFNldHRpbmcge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnU2V0dGluZ3NFZGl0b3InIGFzIGNvbnN0XG5cbiAgICBhc3luYyBnZXRWYWx1ZSAoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IGNoZWNrZWQgPSBhd2FpdCB0aGlzLmNoZWNrYm94U2V0dGluZyQuZ2V0QXR0cmlidXRlKHRoaXMubG9jYXRvcnMuY2hlY2tib3hDaGVja2VkKVxuICAgICAgICBpZiAoY2hlY2tlZCA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGFzeW5jIHNldFZhbHVlICh2YWx1ZTogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5nZXRWYWx1ZSgpICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jaGVja2JveFNldHRpbmckLmNsaWNrKClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaW5rU2V0dGluZyBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBTZXR0aW5nc0VkaXRvckxvY2F0b3JzPiB7fVxuLyoqXG4gKiBTZXR0aW5nIHdpdGggbm8gdmFsdWUsIHdpdGggYSBsaW5rIHRvIHNldHRpbmdzLmpzb24gaW5zdGVhZFxuICpcbiAqIEBjYXRlZ29yeSBFZGl0b3JcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoU2V0dGluZ3NFZGl0b3JMb2NhdG9ycylcbmV4cG9ydCBjbGFzcyBMaW5rU2V0dGluZyBleHRlbmRzIFNldHRpbmcge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnU2V0dGluZ3NFZGl0b3InIGFzIGNvbnN0XG5cbiAgICBnZXRWYWx1ZSAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgZ2V0VmFsdWUgaXMgbm90IGF2YWlsYWJsZSBmb3IgTGlua1NldHRpbmcnKVxuICAgIH1cblxuICAgIHNldFZhbHVlICgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgc2V0VmFsdWUgaXMgbm90IGF2YWlsYWJsZSBmb3IgTGlua1NldHRpbmcnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIGxpbmsgdGhhdCBsZWFkcyB0byB0aGUgdmFsdWUgaW4gc2V0dGluZ3MuanNvblxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGxpbmsgaGFzIGJlZW4gY2xpY2tlZFxuICAgICAqL1xuICAgIGFzeW5jIG9wZW5MaW5rICgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5saW5rQnV0dG9uJC5jbGljaygpXG4gICAgfVxufVxuIl19