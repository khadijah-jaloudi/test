import { ChainablePromiseElement } from 'webdriverio';
import { ContentAssist, ContextMenu, InputBox } from '../index.js';
import { Editor, EditorLocators } from './Editor.js';
import { IPageDecorator, BasePage, ElementWithContextMenu, VSCodeLocatorMap } from '../utils.js';
import { TextEditor as TextEditorLocators, FindWidget as FindWidgetLocators } from '../../locators/1.73.0.js';
export interface TextEditor extends IPageDecorator<EditorLocators> {
}
/**
 * Page object representing the active text editor
 *
 * @category Editor
 */
export declare class TextEditor extends Editor<EditorLocators> {
    /**
     * @private
     */
    locatorKey: "TextEditor";
    /**
     * Find whether the active editor has unsaved changes
     * @returns Promise resolving to true/false
     */
    isDirty(): Promise<boolean>;
    /**
     * Saves the active editor
     * @returns Promise resolving when ctrl+s is invoked
     */
    save(): Promise<void>;
    /**
     * Open the Save as prompt
     *
     * @returns InputBox serving as a simple file dialog
     */
    saveAs(): Promise<InputBox>;
    /**
     * Retrieve the Uri of the file opened in the active editor
     * @returns Promise resolving to editor's underlying Uri
     */
    getFileUri(): Promise<string>;
    /**
     * Retrieve the path to the file opened in the active editor
     * @returns Promise resolving to editor's underlying file path
     */
    getFilePath(): Promise<string>;
    /**
     * Open/Close the content assistant at the current position in the editor by sending the default
     * keyboard shortcut signal
     * @param open true to open, false to close
     * @returns Promise resolving to ContentAssist object when opening, void otherwise
     */
    toggleContentAssist(open: boolean): Promise<ContentAssist | undefined>;
    /**
     * Get all text from the editor
     * @returns Promise resolving to editor text
     */
    getText(): Promise<string>;
    /**
     * Replace the contents of the editor with a given text
     * @param text text to type into the editor
     * @param formatText format the new text, default false
     * @returns Promise resolving once the new text is copied over
     */
    setText(text: string, formatText?: boolean): Promise<void>;
    /**
     * Deletes all text within the editor
     * @returns Promise resolving once the text is deleted
     */
    clearText(): Promise<void>;
    /**
     * Get text from a given line
     * @param line number of the line to retrieve
     * @returns Promise resolving to text at the given line number
     */
    getTextAtLine(line: number): Promise<string>;
    /**
     * Replace the contents of a line with a given text
     * @param line number of the line to edit
     * @param text text to set at the line
     * @returns Promise resolving when the text is typed in
     */
    setTextAtLine(line: number, text: string): Promise<void>;
    /**
     * Get line number that contains the given text. Not suitable for multi line inputs.
     *
     * @param text text to search for
     * @param occurrence select which occurrence of the search text to look for in case
     *                   there are multiple in the document, defaults to 1 (the first instance)
     *
     * @returns Number of the line that contains the start of the given text. -1 if no such text is found.
     * If occurrence number is specified, searches until it finds as many instances of the given text.
     * Returns the line number that holds the last occurrence found this way.
     */
    getLineOfText(text: string, occurrence?: number): Promise<number>;
    /**
     * Find and select a given text. Not usable for multi line selection.
     *
     * @param text text to select
     * @param occurrence specify which onccurrence of text to select if multiple are present in the document
     */
    selectText(text: string, occurrence?: number): Promise<void>;
    /**
     * Get the text that is currently selected as string
     */
    getSelectedText(): Promise<string>;
    /**
     * Get the selection block as a page object
     * @returns Selection page object
     */
    getSelection(): Promise<Selection | undefined>;
    openFindWidget(): Promise<FindWidget>;
    /**
     * Add the given text to the given coordinates
     * @param line number of the line to type into
     * @param column number of the column to start typing at
     * @param text text to add
     * @returns Promise resolving when the text is typed in
     */
    typeTextAt(line: number, column: number, text: string): Promise<void>;
    /**
     * Type given text at the current coordinates
     * @param text text to type
     * @returns promise resolving when the text is typed in
     */
    typeText(text: string): Promise<void>;
    /**
     * Move the cursor to the given coordinates
     * @param line line number to move to
     * @param column column number to move to
     * @returns Promise resolving when the cursor has reached the given coordinates
     */
    moveCursor(line: number, column: number): Promise<void>;
    /**
     * Get number of lines in the editor
     * @returns Promise resolving to number of lines
     */
    getNumberOfLines(): Promise<number>;
    /**
     * Use the built-in 'Format Document' option to format the text
     * @returns Promise resolving when the Format Document command is invoked
     */
    formatDocument(): Promise<void>;
    openContextMenu(): Promise<ContextMenu>;
    /**
     * Get the cursor's coordinates as an array of two numbers: `[line, column]`
     *
     * **Caution** line & column coordinates do not start at `0` but at `1`!
     */
    getCoordinates(): Promise<[number, number]>;
    /**
     * Toggle breakpoint on a given line
     *
     * @param line target line number
     * @returns promise resolving to true when a breakpoint was added, false when removed or
     */
    toggleBreakpoint(line: number): Promise<boolean>;
    /**
     * Get all code lenses within the editor
     * @returns list of CodeLens page objects
     */
    getCodeLenses(): Promise<CodeLens[]>;
    /**
     * Get a code lens based on title, or zero based index
     *
     * @param indexOrTitle zero based index (counting from the top of the editor), or partial title of the code lens
     * @returns CodeLens object if such a code lens exists, undefined otherwise
     */
    getCodeLens(indexOrTitle: number | string): Promise<CodeLens | undefined>;
}
interface Selection extends IPageDecorator<typeof TextEditorLocators> {
}
/**
 * Text selection block
 *
 * @category Editor
 */
declare class Selection extends ElementWithContextMenu<typeof TextEditorLocators> {
    editor: TextEditor;
    /**
     * @private
     */
    locatorKey: "TextEditor";
    constructor(locators: VSCodeLocatorMap, element: ChainablePromiseElement<WebdriverIO.Element>, editor: TextEditor);
    openContextMenu(): Promise<ContextMenu>;
}
export interface CodeLens extends IPageDecorator<typeof TextEditorLocators> {
}
/**
 * Page object for Code Lens inside a text editor
 *
 * @category Editor
 */
export declare class CodeLens extends BasePage<typeof TextEditorLocators> {
    editor: TextEditor;
    /**
     * @private
     */
    locatorKey: "TextEditor";
    constructor(locators: VSCodeLocatorMap, element: ChainablePromiseElement<WebdriverIO.Element>, editor: TextEditor);
    /**
     * Get the text displayed on the code lens
     * @returns text as string
     */
    getText(): Promise<string>;
    /**
     * Get tooltip of the code lens
     * @returns tooltip as string
     */
    getTooltip(): Promise<string>;
}
export interface FindWidget extends IPageDecorator<typeof FindWidgetLocators> {
}
/**
 * Text Editor's Find Widget
 *
 * @category Editor
 */
export declare class FindWidget extends BasePage<typeof FindWidgetLocators> {
    textEditor: TextEditor;
    /**
     * @private
     */
    locatorKey: "FindWidget";
    constructor(locators: VSCodeLocatorMap, element: ChainablePromiseElement<WebdriverIO.Element>, textEditor: TextEditor);
    /**
     * Toggle between find and replace mode
     * @param replace true for replace, false for find
     */
    toggleReplace(replace: boolean): Promise<void>;
    /**
     * Set text in the search box
     * @param text text to fill in
     */
    setSearchText(text: string): Promise<void>;
    /**
     * Get text from Find input box
     * @returns value of find input as string
     */
    getSearchText(): Promise<string>;
    /**
     * Set text in the replace box. Will toggle replace mode on if called in find mode.
     * @param text text to fill in
     */
    setReplaceText(text: string): Promise<void>;
    /**
     * Get text from Replace input box
     * @returns value of replace input as string
     */
    getReplaceText(): Promise<string>;
    /**
     * Click 'Next match'
     */
    nextMatch(): Promise<void>;
    /**
     * Click 'Previous match'
     */
    previousMatch(): Promise<void>;
    /**
     * Click 'Replace'. Only works in replace mode.
     */
    replace(): Promise<void>;
    /**
     * Click 'Replace All'. Only works in replace mode.
     */
    replaceAll(): Promise<void>;
    /**
     * Close the widget.
     */
    close(): Promise<void>;
    /**
     * Get the number of results as an ordered pair of numbers
     * @returns pair in form of [current result index, total number of results]
     */
    getResultCount(): Promise<[number, number]>;
    /**
     * Toggle the search to match case
     * @param toggle true to turn on, false to turn off
     */
    toggleMatchCase(toggle: boolean): Promise<void>;
    /**
     * Toggle the search to match whole words
     * @param toggle true to turn on, false to turn off
     */
    toggleMatchWholeWord(toggle: boolean): Promise<void>;
    /**
     * Toggle the search to use regular expressions
     * @param toggle true to turn on, false to turn off
     */
    toggleUseRegularExpression(toggle: boolean): Promise<void>;
    /**
     * Toggle the replace to preserve case
     * @param toggle true to turn on, false to turn off
     */
    togglePreserveCase(toggle: boolean): Promise<void>;
    private toggleControl;
    private clickButton;
    private setText;
    private getInputText;
}
export {};
//# sourceMappingURL=TextEditor.d.ts.map