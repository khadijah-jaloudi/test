var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import clipboard from 'clipboardy';
import { Key } from 'webdriverio';
import { BasePage, PageDecorator, sleep } from '../utils.js';
import { Input as InputLocators, InputBox as InputBoxLocators, QuickOpenBox as QuickOpenBoxLocators } from '../../locators/1.73.0.js';
import { CMD_KEY } from '../../constants.js';
const HOME_KEY = process.platform === 'win32'
    ? 'a'
    : Key.Home;
/**
 * Abstract page object for input fields
 *
 * @category Workbench
 */
export class Input extends BasePage {
    /**
     * Get current text of the input field
     * @returns Promise resolving to text of the input field
     */
    async getText() {
        const input = await this.inputBox$.$(this.locators.input);
        return input.getAttribute('value');
    }
    /**
     * Set (by selecting all and typing) text in the input field
     * @param text text to set into the input field
     * @returns Promise resolving when the text is typed in
     */
    async setText(text) {
        const input = await this.inputBox$.$(this.locators.input);
        await this.clear();
        await sleep(200);
        if ((await this.getText())?.length > 0) {
            await input.click();
            await browser.action('key')
                .down(Key.End).down(Key.Shift).down(Key.Home)
                .up(Key.End).up(Key.Shift).up(Key.Home)
                .perform();
        }
        await input.addValue(text);
        // fallback to clipboard if the text gets malformed
        const currentText = await this.getText();
        if (currentText !== text) {
            await clipboard.write(text);
            if (currentText?.length) {
                const backSpaces = new Array(currentText.length).fill(Key.Backspace);
                const keyAction = browser.action('key');
                for (const key of backSpaces) {
                    keyAction.down(key).up(key);
                }
                await keyAction.perform();
            }
            await clipboard.write('');
        }
    }
    /**
     * Get the placeholder text for the input field
     * @returns Promise resolving to input placeholder
     */
    async getPlaceHolder() {
        return this.inputBox$.$(this.locators.input).getAttribute('placeholder');
    }
    /**
     * Confirm the input field by pressing Enter
     * @returns Promise resolving when the input is confirmed
     */
    async confirm() {
        await browser.action('key').down(Key.Enter).up(Key.Enter).perform();
    }
    /**
     * Cancel the input field by pressing Escape
     * @returns Promise resolving when the input is cancelled
     */
    async cancel() {
        await browser.action('key').down(Key.Escape).up(Key.Escape).perform();
    }
    /**
     * Clear the input field
     * @returns Promise resolving when the field is cleared
     */
    async clear() {
        const input = await this.inputBox$.$(this.locators.input);
        await input.click();
        // VS Code 1.40 breaks the default clear method, use select all + back space instead
        await browser.action('key')
            .down(Key.End).up(Key.End)
            .perform();
        await browser.action('key')
            .down(CMD_KEY).down(HOME_KEY)
            .up(CMD_KEY).up(HOME_KEY)
            .perform();
        await browser.action('key')
            .down(Key.Backspace)
            .up(Key.Backspace)
            .perform();
        if ((await input.getAttribute('value'))?.length > 0) {
            await browser.action('key')
                .down(Key.End).up(Key.End)
                .perform();
            await browser.action('key')
                .down(CMD_KEY).down(HOME_KEY)
                .up(CMD_KEY).up(HOME_KEY)
                .perform();
            await browser.action('key')
                .down(Key.Backspace).up(Key.Backspace)
                .perform();
        }
    }
    /**
     * Select (click) a quick pick option. Will scroll through the quick picks to find the item.
     * Search for the item can be done by its text, or index in the quick pick menu.
     * Note that scrolling does not affect the item's index, but it will
     * replace some items in the DOM (thus they become unreachable)
     *
     * @param indexOrText index (number) or text (string) of the item to search by
     * @returns Promise resolving when the given quick pick is selected
     */
    async selectQuickPick(indexOrText) {
        const pick = await this.findQuickPick(indexOrText);
        if (pick) {
            await pick.select();
        }
        else {
            await this.resetPosition();
        }
    }
    /**
     * Select/Deselect all quick picks using the 'select all' checkbox
     * If multiple selection is disabled on the input box, no action is performed
     *
     * @param state true to select all, false to deselect all
     * @returns Promise resolving when all quick picks have been toggled to desired state
     */
    async toggleAllQuickPicks(state) {
        const checkboxes = await this.quickPickSelectAll$$;
        if (checkboxes.length < 0) {
            return;
        }
        if (!await checkboxes[0].isSelected()) {
            await checkboxes[0].click();
        }
        if (state === false) {
            await checkboxes[0].click();
        }
    }
    /**
     * Scroll through the quick picks to find an item by the name or index
     * @param indexOrText index (number) or text (string) of the item to search by
     * @returns Promise resolvnig to QuickPickItem if found, to undefined otherwise
     */
    async findQuickPick(indexOrText) {
        const first = await this.quickPickPosition$$(1);
        if (first.length < 1) {
            await this.resetPosition();
        }
        let endReached = false;
        while (!endReached) {
            const picks = await this.getQuickPicks();
            for (const pick of picks) {
                const lastRow = await this.elem.$$(this.locatorMap.DefaultTreeSection.lastRow);
                if (lastRow.length > 0) {
                    endReached = true;
                }
                else if (await pick.elem.getAttribute('aria-posinset') === await pick.elem.getAttribute('aria-setsize')) {
                    endReached = true;
                }
                if (typeof indexOrText === 'string') {
                    const text = await pick.getLabel();
                    if (text.indexOf(indexOrText) > -1) {
                        return pick;
                    }
                }
                else if (indexOrText === pick.getIndex()) {
                    return pick;
                }
            }
            if (!endReached) {
                await browser.action('key').down(Key.PageDown).up(Key.PageDown).perform();
            }
        }
        return undefined;
    }
    /**
     * Retrieve the title of an input box if it has one
     * @returns Promise resolving to title if it exists, to undefined otherwise
     */
    async getTitle() {
        const titleBar = await this.titleBar$$;
        if (titleBar.length > 0 && await titleBar[0].isDisplayed()) {
            return (await titleBar[0].$(this.locators.title)).getText();
        }
        return undefined;
    }
    /**
     * Click on the back button if it exists
     * @returns Promise resolving to true if a button was clicked, to false otherwise
     */
    async back() {
        const titleBar = await this.titleBar$$;
        if (titleBar.length > 0 && await titleBar[0].isDisplayed()) {
            const backBtn = await titleBar[0].$$(this.locators.backButton);
            if (backBtn.length > 0 && await backBtn[0].isEnabled()) {
                await backBtn[0].click();
                return true;
            }
        }
        return false;
    }
    async resetPosition() {
        const text = await this.getText();
        await this.clear();
        await this.setText(text || '');
    }
}
/**
 * Page object representing a quick pick option in the input box
 *
 * @category Workbench
 */
export let QuickPickItem = class QuickPickItem extends BasePage {
    constructor(locators, index, inputField) {
        const quickPickPositionFn = locators.Input.quickPickPosition;
        const quickPickIndexFn = locators.Input.quickPickIndex;
        const baseParam = inputField instanceof QuickOpenBox
            ? quickPickPositionFn(index)
            : quickPickIndexFn(index);
        super(locators, baseParam);
        /**
         * @private
         */
        this.locatorKey = 'Input';
        this.index = index;
        this.input = inputField;
    }
    /**
     * Get the label of the quick pick item
     */
    async getLabel() {
        return this.quickPickLabel$.getText();
    }
    /**
     * Get the description of the quick pick item
     */
    async getDescription() {
        try {
            return await this.quickPickDescription$.getText();
        }
        catch (err) {
            return undefined;
        }
    }
    /**
     * Get the index of the quick pick item
     */
    getIndex() {
        return this.index;
    }
    /**
     * Select (click) the quick pick item
     * @returns Promise resolving when the item has been clicked
     */
    async select() {
        await this.elem.click();
    }
};
QuickPickItem = __decorate([
    PageDecorator(InputLocators)
], QuickPickItem);
/**
 * Plain input box variation of the input page object
 *
 * @category Workbench
 */
export let InputBox = class InputBox extends Input {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = ['Input', 'InputBox'];
    }
    /**
     * Get the message below the input field
     */
    async getMessage() {
        return this.message$.getText();
    }
    async hasProgress() {
        const klass = await this.progress$.getAttribute('class');
        return klass.indexOf('done') < 0;
    }
    async getQuickPicks() {
        const picks = [];
        const elements = await this.quickList$
            .$(this.locators.rows)
            .$$(this.locators.row);
        for (const element of elements) {
            if (await element.isDisplayed()) {
                picks.push(await new QuickPickItem(this.locatorMap, parseInt(await element.getAttribute('data-index'), 10), this).wait());
            }
        }
        return picks;
    }
    /**
     * Find whether the input is showing an error
     * @returns Promise resolving to notification message
     */
    async hasError() {
        const klass = await this.inputBox$.getAttribute('class');
        return klass.indexOf('error') > -1;
    }
    /**
     * Check if the input field is masked (input type password)
     * @returns Promise resolving to notification message
     */
    async isPassword() {
        return (await this.input$.getAttribute('type')) === 'password';
    }
};
InputBox = __decorate([
    PageDecorator({ ...InputLocators, ...InputBoxLocators })
], InputBox);
/**
 * @deprecated as of VS Code 1.44.0, quick open box has been replaced with input box
 * The quick open box variation of the input
 *
 * @category Workbench
 */
export let QuickOpenBox = class QuickOpenBox extends Input {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = ['Input', 'QuickOpenBox'];
    }
    async hasProgress() {
        const klass = await this.progress$
            .getAttribute('class');
        return klass.indexOf('done') < 0;
    }
    async getQuickPicks() {
        const picks = [];
        const tree = await browser.$(this.locators.quickList);
        await tree.waitForExist({ timeout: 1000 });
        const elements = await tree.$$(this.locators.row);
        for (const element of elements) {
            const index = parseInt(await element.getAttribute('aria-posinset'), 10);
            if (await element.isDisplayed()) {
                picks.push(await new QuickPickItem(this.locatorMap, index, this).wait());
            }
        }
        return picks;
    }
};
QuickOpenBox = __decorate([
    PageDecorator({ ...InputLocators, ...QuickOpenBoxLocators })
], QuickOpenBox);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5wdXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcGFnZW9iamVjdHMvd29ya2JlbmNoL0lucHV0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sU0FBUyxNQUFNLFlBQVksQ0FBQTtBQUNsQyxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sYUFBYSxDQUFBO0FBRWpDLE9BQU8sRUFDYSxRQUFRLEVBQUUsYUFBYSxFQUFvQixLQUFLLEVBQ25FLE1BQU0sYUFBYSxDQUFBO0FBQ3BCLE9BQU8sRUFDSCxLQUFLLElBQUksYUFBYSxFQUN0QixRQUFRLElBQUksZ0JBQWdCLEVBQzVCLFlBQVksSUFBSSxvQkFBb0IsRUFDdkMsTUFBTSwwQkFBMEIsQ0FBQTtBQUNqQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sb0JBQW9CLENBQUE7QUFFNUMsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLFFBQVEsS0FBSyxPQUFPO0lBQ3pDLENBQUMsQ0FBQyxHQUFHO0lBQ0wsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUE7QUFJZDs7OztHQUlHO0FBQ0gsTUFBTSxPQUFnQixLQUFNLFNBQVEsUUFBMEI7SUFDMUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLE9BQU87UUFDVCxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUE7UUFDekQsT0FBTyxLQUFLLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFBO0lBQ3RDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLE9BQU8sQ0FBRSxJQUFZO1FBQ3ZCLE1BQU0sS0FBSyxHQUFHLE1BQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQTtRQUN6RCxNQUFNLElBQUksQ0FBQyxLQUFLLEVB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QUFNLEtBQUssR0FBRyxRQUFRLENBQUMsTUFBTSxPQUFPLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFBO1lBQ3ZFLElBQUksTUFBTSxPQUFPLENBQUMsV0FBVyxFQUFFLEVBQUU7Z0JBQzdCLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxJQUFJLGFBQWEsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFBO2FBQzNFO1NBQ0o7UUFDRCxPQUFPLEtBQUssQ0FBQTtJQUNoQixDQUFDO0NBQ0osQ0FBQTtBQXpCWSxZQUFZO0lBRHhCLGFBQWEsQ0FBQyxFQUFFLEdBQUcsYUFBYSxFQUFFLEdBQUcsb0JBQW9CLEVBQUUsQ0FBQztHQUNoRCxZQUFZLENBeUJ4QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjbGlwYm9hcmQgZnJvbSAnY2xpcGJvYXJkeSdcbmltcG9ydCB7IEtleSB9IGZyb20gJ3dlYmRyaXZlcmlvJ1xuXG5pbXBvcnQge1xuICAgIElQYWdlRGVjb3JhdG9yLCBCYXNlUGFnZSwgUGFnZURlY29yYXRvciwgVlNDb2RlTG9jYXRvck1hcCwgc2xlZXBcbn0gZnJvbSAnLi4vdXRpbHMuanMnXG5pbXBvcnQge1xuICAgIElucHV0IGFzIElucHV0TG9jYXRvcnMsXG4gICAgSW5wdXRCb3ggYXMgSW5wdXRCb3hMb2NhdG9ycyxcbiAgICBRdWlja09wZW5Cb3ggYXMgUXVpY2tPcGVuQm94TG9jYXRvcnNcbn0gZnJvbSAnLi4vLi4vbG9jYXRvcnMvMS43My4wLmpzJ1xuaW1wb3J0IHsgQ01EX0tFWSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcydcblxuY29uc3QgSE9NRV9LRVkgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInXG4gICAgPyAnYSdcbiAgICA6IEtleS5Ib21lXG5cbnR5cGUgQWxsSW5wdXRMb2NhdG9ycyA9IHR5cGVvZiBJbnB1dExvY2F0b3JzICYgdHlwZW9mIElucHV0Qm94TG9jYXRvcnMgJiB0eXBlb2YgUXVpY2tPcGVuQm94TG9jYXRvcnNcbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXQgZXh0ZW5kcyBJUGFnZURlY29yYXRvcjxBbGxJbnB1dExvY2F0b3JzPiB7fVxuLyoqXG4gKiBBYnN0cmFjdCBwYWdlIG9iamVjdCBmb3IgaW5wdXQgZmllbGRzXG4gKlxuICogQGNhdGVnb3J5IFdvcmtiZW5jaFxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSW5wdXQgZXh0ZW5kcyBCYXNlUGFnZTxBbGxJbnB1dExvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogR2V0IGN1cnJlbnQgdGV4dCBvZiB0aGUgaW5wdXQgZmllbGRcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0ZXh0IG9mIHRoZSBpbnB1dCBmaWVsZFxuICAgICAqL1xuICAgIGFzeW5jIGdldFRleHQgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gYXdhaXQgdGhpcy5pbnB1dEJveCQuJCh0aGlzLmxvY2F0b3JzLmlucHV0KVxuICAgICAgICByZXR1cm4gaW5wdXQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IChieSBzZWxlY3RpbmcgYWxsIGFuZCB0eXBpbmcpIHRleHQgaW4gdGhlIGlucHV0IGZpZWxkXG4gICAgICogQHBhcmFtIHRleHQgdGV4dCB0byBzZXQgaW50byB0aGUgaW5wdXQgZmllbGRcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSB0ZXh0IGlzIHR5cGVkIGluXG4gICAgICovXG4gICAgYXN5bmMgc2V0VGV4dCAodGV4dDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gYXdhaXQgdGhpcy5pbnB1dEJveCQuJCh0aGlzLmxvY2F0b3JzLmlucHV0KVxuICAgICAgICBhd2FpdCB0aGlzLmNsZWFyKClcbiAgICAgICAgYXdhaXQgc2xlZXAoMjAwKVxuICAgICAgICBpZiAoKGF3YWl0IHRoaXMuZ2V0VGV4dCgpKT8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgaW5wdXQuY2xpY2soKVxuICAgICAgICAgICAgYXdhaXQgYnJvd3Nlci5hY3Rpb24oJ2tleScpXG4gICAgICAgICAgICAgICAgLmRvd24oS2V5LkVuZCkuZG93bihLZXkuU2hpZnQpLmRvd24oS2V5LkhvbWUpXG4gICAgICAgICAgICAgICAgLnVwKEtleS5FbmQpLnVwKEtleS5TaGlmdCkudXAoS2V5LkhvbWUpXG4gICAgICAgICAgICAgICAgLnBlcmZvcm0oKVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGlucHV0LmFkZFZhbHVlKHRleHQpXG5cbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gY2xpcGJvYXJkIGlmIHRoZSB0ZXh0IGdldHMgbWFsZm9ybWVkXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUZXh0ID0gYXdhaXQgdGhpcy5nZXRUZXh0KClcbiAgICAgICAgaWYgKGN1cnJlbnRUZXh0ICE9PSB0ZXh0KSB7XG4gICAgICAgICAgICBhd2FpdCBjbGlwYm9hcmQud3JpdGUodGV4dClcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGV4dD8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFja1NwYWNlczogc3RyaW5nW10gPSBuZXcgQXJyYXkoY3VycmVudFRleHQubGVuZ3RoKS5maWxsKEtleS5CYWNrc3BhY2UpXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5QWN0aW9uID0gYnJvd3Nlci5hY3Rpb24oJ2tleScpXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgYmFja1NwYWNlcykge1xuICAgICAgICAgICAgICAgICAgICBrZXlBY3Rpb24uZG93bihrZXkpLnVwKGtleSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQga2V5QWN0aW9uLnBlcmZvcm0oKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgY2xpcGJvYXJkLndyaXRlKCcnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwbGFjZWhvbGRlciB0ZXh0IGZvciB0aGUgaW5wdXQgZmllbGRcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBpbnB1dCBwbGFjZWhvbGRlclxuICAgICAqL1xuICAgIGFzeW5jIGdldFBsYWNlSG9sZGVyICgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dEJveCQuJCh0aGlzLmxvY2F0b3JzLmlucHV0KS5nZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25maXJtIHRoZSBpbnB1dCBmaWVsZCBieSBwcmVzc2luZyBFbnRlclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGlucHV0IGlzIGNvbmZpcm1lZFxuICAgICAqL1xuICAgIGFzeW5jIGNvbmZpcm0gKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCBicm93c2VyLmFjdGlvbigna2V5JykuZG93bihLZXkuRW50ZXIpLnVwKEtleS5FbnRlcikucGVyZm9ybSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VsIHRoZSBpbnB1dCBmaWVsZCBieSBwcmVzc2luZyBFc2NhcGVcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBpbnB1dCBpcyBjYW5jZWxsZWRcbiAgICAgKi9cbiAgICBhc3luYyBjYW5jZWwgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCBicm93c2VyLmFjdGlvbigna2V5JykuZG93bihLZXkuRXNjYXBlKS51cChLZXkuRXNjYXBlKS5wZXJmb3JtKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgaW5wdXQgZmllbGRcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBmaWVsZCBpcyBjbGVhcmVkXG4gICAgICovXG4gICAgYXN5bmMgY2xlYXIgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGF3YWl0IHRoaXMuaW5wdXRCb3gkLiQodGhpcy5sb2NhdG9ycy5pbnB1dClcbiAgICAgICAgYXdhaXQgaW5wdXQuY2xpY2soKVxuICAgICAgICAvLyBWUyBDb2RlIDEuNDAgYnJlYWtzIHRoZSBkZWZhdWx0IGNsZWFyIG1ldGhvZCwgdXNlIHNlbGVjdCBhbGwgKyBiYWNrIHNwYWNlIGluc3RlYWRcbiAgICAgICAgYXdhaXQgYnJvd3Nlci5hY3Rpb24oJ2tleScpXG4gICAgICAgICAgICAuZG93bihLZXkuRW5kKS51cChLZXkuRW5kKVxuICAgICAgICAgICAgLnBlcmZvcm0oKVxuICAgICAgICBhd2FpdCBicm93c2VyLmFjdGlvbigna2V5JylcbiAgICAgICAgICAgIC5kb3duKENNRF9LRVkpLmRvd24oSE9NRV9LRVkpXG4gICAgICAgICAgICAudXAoQ01EX0tFWSkudXAoSE9NRV9LRVkpXG4gICAgICAgICAgICAucGVyZm9ybSgpXG4gICAgICAgIGF3YWl0IGJyb3dzZXIuYWN0aW9uKCdrZXknKVxuICAgICAgICAgICAgLmRvd24oS2V5LkJhY2tzcGFjZSlcbiAgICAgICAgICAgIC51cChLZXkuQmFja3NwYWNlKVxuICAgICAgICAgICAgLnBlcmZvcm0oKVxuICAgICAgICBpZiAoKGF3YWl0IGlucHV0LmdldEF0dHJpYnV0ZSgndmFsdWUnKSk/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IGJyb3dzZXIuYWN0aW9uKCdrZXknKVxuICAgICAgICAgICAgICAgIC5kb3duKEtleS5FbmQpLnVwKEtleS5FbmQpXG4gICAgICAgICAgICAgICAgLnBlcmZvcm0oKVxuICAgICAgICAgICAgYXdhaXQgYnJvd3Nlci5hY3Rpb24oJ2tleScpXG4gICAgICAgICAgICAgICAgLmRvd24oQ01EX0tFWSkuZG93bihIT01FX0tFWSlcbiAgICAgICAgICAgICAgICAudXAoQ01EX0tFWSkudXAoSE9NRV9LRVkpXG4gICAgICAgICAgICAgICAgLnBlcmZvcm0oKVxuICAgICAgICAgICAgYXdhaXQgYnJvd3Nlci5hY3Rpb24oJ2tleScpXG4gICAgICAgICAgICAgICAgLmRvd24oS2V5LkJhY2tzcGFjZSkudXAoS2V5LkJhY2tzcGFjZSlcbiAgICAgICAgICAgICAgICAucGVyZm9ybSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgKGNsaWNrKSBhIHF1aWNrIHBpY2sgb3B0aW9uLiBXaWxsIHNjcm9sbCB0aHJvdWdoIHRoZSBxdWljayBwaWNrcyB0byBmaW5kIHRoZSBpdGVtLlxuICAgICAqIFNlYXJjaCBmb3IgdGhlIGl0ZW0gY2FuIGJlIGRvbmUgYnkgaXRzIHRleHQsIG9yIGluZGV4IGluIHRoZSBxdWljayBwaWNrIG1lbnUuXG4gICAgICogTm90ZSB0aGF0IHNjcm9sbGluZyBkb2VzIG5vdCBhZmZlY3QgdGhlIGl0ZW0ncyBpbmRleCwgYnV0IGl0IHdpbGxcbiAgICAgKiByZXBsYWNlIHNvbWUgaXRlbXMgaW4gdGhlIERPTSAodGh1cyB0aGV5IGJlY29tZSB1bnJlYWNoYWJsZSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleE9yVGV4dCBpbmRleCAobnVtYmVyKSBvciB0ZXh0IChzdHJpbmcpIG9mIHRoZSBpdGVtIHRvIHNlYXJjaCBieVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGdpdmVuIHF1aWNrIHBpY2sgaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBzZWxlY3RRdWlja1BpY2sgKGluZGV4T3JUZXh0OiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgcGljayA9IGF3YWl0IHRoaXMuZmluZFF1aWNrUGljayhpbmRleE9yVGV4dClcbiAgICAgICAgaWYgKHBpY2spIHtcbiAgICAgICAgICAgIGF3YWl0IHBpY2suc2VsZWN0KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVzZXRQb3NpdGlvbigpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QvRGVzZWxlY3QgYWxsIHF1aWNrIHBpY2tzIHVzaW5nIHRoZSAnc2VsZWN0IGFsbCcgY2hlY2tib3hcbiAgICAgKiBJZiBtdWx0aXBsZSBzZWxlY3Rpb24gaXMgZGlzYWJsZWQgb24gdGhlIGlucHV0IGJveCwgbm8gYWN0aW9uIGlzIHBlcmZvcm1lZFxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlIHRydWUgdG8gc2VsZWN0IGFsbCwgZmFsc2UgdG8gZGVzZWxlY3QgYWxsXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgd2hlbiBhbGwgcXVpY2sgcGlja3MgaGF2ZSBiZWVuIHRvZ2dsZWQgdG8gZGVzaXJlZCBzdGF0ZVxuICAgICAqL1xuICAgIGFzeW5jIHRvZ2dsZUFsbFF1aWNrUGlja3MgKHN0YXRlOiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ZXMgPSBhd2FpdCB0aGlzLnF1aWNrUGlja1NlbGVjdEFsbCQkXG4gICAgICAgIGlmIChjaGVja2JveGVzLmxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmICghYXdhaXQgY2hlY2tib3hlc1swXS5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgIGF3YWl0IGNoZWNrYm94ZXNbMF0uY2xpY2soKVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGF3YWl0IGNoZWNrYm94ZXNbMF0uY2xpY2soKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHRocm91Z2ggdGhlIHF1aWNrIHBpY2tzIHRvIGZpbmQgYW4gaXRlbSBieSB0aGUgbmFtZSBvciBpbmRleFxuICAgICAqIEBwYXJhbSBpbmRleE9yVGV4dCBpbmRleCAobnVtYmVyKSBvciB0ZXh0IChzdHJpbmcpIG9mIHRoZSBpdGVtIHRvIHNlYXJjaCBieVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2bmlnIHRvIFF1aWNrUGlja0l0ZW0gaWYgZm91bmQsIHRvIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhc3luYyBmaW5kUXVpY2tQaWNrIChpbmRleE9yVGV4dDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxRdWlja1BpY2tJdGVtIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IGZpcnN0ID0gYXdhaXQgdGhpcy5xdWlja1BpY2tQb3NpdGlvbiQkKDEpXG4gICAgICAgIGlmIChmaXJzdC5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlc2V0UG9zaXRpb24oKVxuICAgICAgICB9XG4gICAgICAgIGxldCBlbmRSZWFjaGVkID0gZmFsc2VcblxuICAgICAgICB3aGlsZSAoIWVuZFJlYWNoZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBpY2tzID0gYXdhaXQgdGhpcy5nZXRRdWlja1BpY2tzKClcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGljayBvZiBwaWNrcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RSb3cgPSBhd2FpdCB0aGlzLmVsZW0uJCQodGhpcy5sb2NhdG9yTWFwLkRlZmF1bHRUcmVlU2VjdGlvbi5sYXN0Um93IGFzIHN0cmluZylcbiAgICAgICAgICAgICAgICBpZiAobGFzdFJvdy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZFJlYWNoZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcGljay5lbGVtLmdldEF0dHJpYnV0ZSgnYXJpYS1wb3NpbnNldCcpID09PSBhd2FpdCBwaWNrLmVsZW0uZ2V0QXR0cmlidXRlKCdhcmlhLXNldHNpemUnKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBlbmRSZWFjaGVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4T3JUZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcGljay5nZXRMYWJlbCgpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0LmluZGV4T2YoaW5kZXhPclRleHQpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwaWNrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4T3JUZXh0ID09PSBwaWNrLmdldEluZGV4KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBpY2tcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVuZFJlYWNoZWQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBicm93c2VyLmFjdGlvbigna2V5JykuZG93bihLZXkuUGFnZURvd24pLnVwKEtleS5QYWdlRG93bikucGVyZm9ybSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSB0aXRsZSBvZiBhbiBpbnB1dCBib3ggaWYgaXQgaGFzIG9uZVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRpdGxlIGlmIGl0IGV4aXN0cywgdG8gdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGFzeW5jIGdldFRpdGxlICgpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgICAgICBjb25zdCB0aXRsZUJhciA9IGF3YWl0IHRoaXMudGl0bGVCYXIkJFxuICAgICAgICBpZiAodGl0bGVCYXIubGVuZ3RoID4gMCAmJiBhd2FpdCB0aXRsZUJhclswXS5pc0Rpc3BsYXllZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gKGF3YWl0IHRpdGxlQmFyWzBdLiQodGhpcy5sb2NhdG9ycy50aXRsZSkpLmdldFRleHQoKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGljayBvbiB0aGUgYmFjayBidXR0b24gaWYgaXQgZXhpc3RzXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdHJ1ZSBpZiBhIGJ1dHRvbiB3YXMgY2xpY2tlZCwgdG8gZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgYXN5bmMgYmFjayAoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IHRpdGxlQmFyID0gYXdhaXQgdGhpcy50aXRsZUJhciQkXG4gICAgICAgIGlmICh0aXRsZUJhci5sZW5ndGggPiAwICYmIGF3YWl0IHRpdGxlQmFyWzBdLmlzRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhY2tCdG4gPSBhd2FpdCB0aXRsZUJhclswXS4kJCh0aGlzLmxvY2F0b3JzLmJhY2tCdXR0b24pXG4gICAgICAgICAgICBpZiAoYmFja0J0bi5sZW5ndGggPiAwICYmIGF3YWl0IGJhY2tCdG5bMF0uaXNFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBiYWNrQnRuWzBdLmNsaWNrKClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgd2hldGhlciB0aGUgaW5wdXQgYm94IGhhcyBhbiBhY3RpdmUgcHJvZ3Jlc3MgYmFyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdHJ1ZS9mYWxzZVxuICAgICAqL1xuICAgIGFic3RyYWN0IGhhc1Byb2dyZXNzICgpOiBQcm9taXNlPGJvb2xlYW4+XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgcXVpY2sgcGljayBpdGVtcyBjdXJyZW50bHkgYXZhaWxhYmxlIGluIHRoZSBET01cbiAgICAgKiAodmlzaWJsZSBpbiB0aGUgcXVpY2sgcGljayBtZW51KVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGFycmF5IG9mIFF1aWNrUGlja0l0ZW0gb2JqZWN0c1xuICAgICAqL1xuICAgIGFic3RyYWN0IGdldFF1aWNrUGlja3MgKCk6IFByb21pc2U8UXVpY2tQaWNrSXRlbVtdPlxuXG4gICAgcHJpdmF0ZSBhc3luYyByZXNldFBvc2l0aW9uICgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHRoaXMuZ2V0VGV4dCgpXG4gICAgICAgIGF3YWl0IHRoaXMuY2xlYXIoKVxuICAgICAgICBhd2FpdCB0aGlzLnNldFRleHQodGV4dCB8fCAnJylcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVpY2tQaWNrSXRlbSBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBJbnB1dExvY2F0b3JzPiB7fVxuLyoqXG4gKiBQYWdlIG9iamVjdCByZXByZXNlbnRpbmcgYSBxdWljayBwaWNrIG9wdGlvbiBpbiB0aGUgaW5wdXQgYm94XG4gKlxuICogQGNhdGVnb3J5IFdvcmtiZW5jaFxuICovXG5AUGFnZURlY29yYXRvcihJbnB1dExvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIFF1aWNrUGlja0l0ZW0gZXh0ZW5kcyBCYXNlUGFnZTx0eXBlb2YgSW5wdXRMb2NhdG9ycz4ge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnSW5wdXQnIGFzIGNvbnN0XG4gICAgcHJpdmF0ZSBpbmRleDogbnVtYmVyXG4gICAgcHVibGljIGlucHV0OiBJbnB1dFxuXG4gICAgY29uc3RydWN0b3IgKGxvY2F0b3JzOiBWU0NvZGVMb2NhdG9yTWFwLCBpbmRleDogbnVtYmVyLCBpbnB1dEZpZWxkOiBJbnB1dCkge1xuICAgICAgICBjb25zdCBxdWlja1BpY2tQb3NpdGlvbkZuID0gbG9jYXRvcnMuSW5wdXQucXVpY2tQaWNrUG9zaXRpb24gYXMgRnVuY3Rpb25cbiAgICAgICAgY29uc3QgcXVpY2tQaWNrSW5kZXhGbiA9IGxvY2F0b3JzLklucHV0LnF1aWNrUGlja0luZGV4IGFzIEZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IGJhc2VQYXJhbSA9IGlucHV0RmllbGQgaW5zdGFuY2VvZiBRdWlja09wZW5Cb3hcbiAgICAgICAgICAgID8gcXVpY2tQaWNrUG9zaXRpb25GbihpbmRleCkgYXMgc3RyaW5nXG4gICAgICAgICAgICA6IHF1aWNrUGlja0luZGV4Rm4oaW5kZXgpIGFzIHN0cmluZ1xuICAgICAgICBzdXBlcihsb2NhdG9ycywgYmFzZVBhcmFtKVxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXhcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0RmllbGRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxhYmVsIG9mIHRoZSBxdWljayBwaWNrIGl0ZW1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRMYWJlbCAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVpY2tQaWNrTGFiZWwkLmdldFRleHQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIHF1aWNrIHBpY2sgaXRlbVxuICAgICAqL1xuICAgIGFzeW5jIGdldERlc2NyaXB0aW9uICgpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucXVpY2tQaWNrRGVzY3JpcHRpb24kLmdldFRleHQoKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5kZXggb2YgdGhlIHF1aWNrIHBpY2sgaXRlbVxuICAgICAqL1xuICAgIGdldEluZGV4ICgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCAoY2xpY2spIHRoZSBxdWljayBwaWNrIGl0ZW1cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBpdGVtIGhhcyBiZWVuIGNsaWNrZWRcbiAgICAgKi9cbiAgICBhc3luYyBzZWxlY3QgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCB0aGlzLmVsZW0uY2xpY2soKVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbnB1dEJveCBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBJbnB1dEJveExvY2F0b3JzPiB7fVxuLyoqXG4gKiBQbGFpbiBpbnB1dCBib3ggdmFyaWF0aW9uIG9mIHRoZSBpbnB1dCBwYWdlIG9iamVjdFxuICpcbiAqIEBjYXRlZ29yeSBXb3JrYmVuY2hcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoeyAuLi5JbnB1dExvY2F0b3JzLCAuLi5JbnB1dEJveExvY2F0b3JzIH0pXG5leHBvcnQgY2xhc3MgSW5wdXRCb3ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9IFsnSW5wdXQnIGFzIGNvbnN0LCAnSW5wdXRCb3gnIGFzIGNvbnN0XVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBtZXNzYWdlIGJlbG93IHRoZSBpbnB1dCBmaWVsZFxuICAgICAqL1xuICAgIGFzeW5jIGdldE1lc3NhZ2UgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2UkLmdldFRleHQoKVxuICAgIH1cblxuICAgIGFzeW5jIGhhc1Byb2dyZXNzICgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3Qga2xhc3MgPSBhd2FpdCB0aGlzLnByb2dyZXNzJC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJylcbiAgICAgICAgcmV0dXJuIGtsYXNzLmluZGV4T2YoJ2RvbmUnKSA8IDBcbiAgICB9XG5cbiAgICBhc3luYyBnZXRRdWlja1BpY2tzICgpOiBQcm9taXNlPFF1aWNrUGlja0l0ZW1bXT4ge1xuICAgICAgICBjb25zdCBwaWNrczogUXVpY2tQaWNrSXRlbVtdID0gW11cbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBhd2FpdCB0aGlzLnF1aWNrTGlzdCRcbiAgICAgICAgICAgIC4kKHRoaXMubG9jYXRvcnMucm93cylcbiAgICAgICAgICAgIC4kJCh0aGlzLmxvY2F0b3JzLnJvdylcblxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGlmIChhd2FpdCBlbGVtZW50LmlzRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgICAgICBwaWNrcy5wdXNoKGF3YWl0IG5ldyBRdWlja1BpY2tJdGVtKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2F0b3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGF3YWl0IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWluZGV4JyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAgICkud2FpdCgpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaWNrc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgd2hldGhlciB0aGUgaW5wdXQgaXMgc2hvd2luZyBhbiBlcnJvclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIG5vdGlmaWNhdGlvbiBtZXNzYWdlXG4gICAgICovXG4gICAgYXN5bmMgaGFzRXJyb3IgKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBjb25zdCBrbGFzcyA9IGF3YWl0IHRoaXMuaW5wdXRCb3gkLmdldEF0dHJpYnV0ZSgnY2xhc3MnKVxuICAgICAgICByZXR1cm4ga2xhc3MuaW5kZXhPZignZXJyb3InKSA+IC0xXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGlucHV0IGZpZWxkIGlzIG1hc2tlZCAoaW5wdXQgdHlwZSBwYXNzd29yZClcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBub3RpZmljYXRpb24gbWVzc2FnZVxuICAgICAqL1xuICAgIGFzeW5jIGlzUGFzc3dvcmQgKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuaW5wdXQkLmdldEF0dHJpYnV0ZSgndHlwZScpKSA9PT0gJ3Bhc3N3b3JkJ1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWlja09wZW5Cb3ggZXh0ZW5kcyBJUGFnZURlY29yYXRvcjxBbGxJbnB1dExvY2F0b3JzPiB7fVxuLyoqXG4gKiBAZGVwcmVjYXRlZCBhcyBvZiBWUyBDb2RlIDEuNDQuMCwgcXVpY2sgb3BlbiBib3ggaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBpbnB1dCBib3hcbiAqIFRoZSBxdWljayBvcGVuIGJveCB2YXJpYXRpb24gb2YgdGhlIGlucHV0XG4gKlxuICogQGNhdGVnb3J5IFdvcmtiZW5jaFxuICovXG5AUGFnZURlY29yYXRvcih7IC4uLklucHV0TG9jYXRvcnMsIC4uLlF1aWNrT3BlbkJveExvY2F0b3JzIH0pXG5leHBvcnQgY2xhc3MgUXVpY2tPcGVuQm94IGV4dGVuZHMgSW5wdXQge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSBbJ0lucHV0JyBhcyBjb25zdCwgJ1F1aWNrT3BlbkJveCcgYXMgY29uc3RdXG5cbiAgICBhc3luYyBoYXNQcm9ncmVzcyAoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IGtsYXNzID0gYXdhaXQgdGhpcy5wcm9ncmVzcyRcbiAgICAgICAgICAgIC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJylcbiAgICAgICAgcmV0dXJuIGtsYXNzLmluZGV4T2YoJ2RvbmUnKSA8IDBcbiAgICB9XG5cbiAgICBhc3luYyBnZXRRdWlja1BpY2tzICgpOiBQcm9taXNlPFF1aWNrUGlja0l0ZW1bXT4ge1xuICAgICAgICBjb25zdCBwaWNrczogUXVpY2tQaWNrSXRlbVtdID0gW11cbiAgICAgICAgY29uc3QgdHJlZSA9IGF3YWl0IGJyb3dzZXIuJCh0aGlzLmxvY2F0b3JzLnF1aWNrTGlzdClcbiAgICAgICAgYXdhaXQgdHJlZS53YWl0Rm9yRXhpc3QoeyB0aW1lb3V0OiAxMDAwIH0pXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gYXdhaXQgdHJlZS4kJCh0aGlzLmxvY2F0b3JzLnJvdylcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KGF3YWl0IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLXBvc2luc2V0JyksIDEwKVxuICAgICAgICAgICAgaWYgKGF3YWl0IGVsZW1lbnQuaXNEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgICAgIHBpY2tzLnB1c2goYXdhaXQgbmV3IFF1aWNrUGlja0l0ZW0odGhpcy5sb2NhdG9yTWFwLCBpbmRleCwgdGhpcykud2FpdCgpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaWNrc1xuICAgIH1cbn1cbiJdfQ==