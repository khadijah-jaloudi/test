var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var WebView_1;
import { BasePage, PageDecorator } from '../utils.js';
import { WebView as WebViewLocators } from '../../locators/1.73.0.js';
export let WebView = WebView_1 = class WebView extends BasePage {
    constructor() {
        super(...arguments);
        /**
         * @private locator key to identify locator map (see locators.ts)
         */
        this.locatorKey = 'WebView';
    }
    get activeFrame() {
        return $(this._locators.WebView.activeFrame);
    }
    /**
     * Switch WebDriver context to given webview so subsequent element
     * calls are targeting elements within the webview.
     *
     * __Note:__ ensure to call `webview.close()` to leave the webview
     * context before using other page objects.
     */
    async open() {
        await browser.switchToFrame(this.elem);
        await (await this.activeFrame).waitForExist();
        await browser.switchToFrame(await this.activeFrame);
    }
    /**
     * Switch from the webview context back to the VSCode context.
     */
    async close() {
        await browser.switchToFrame(null);
        await browser.switchToFrame(null);
    }
    /**
     * Get all available WebViews (including the once in the sidebar or from the editor)
     * @param locators locator map
     * @returns a list of webview objects
     */
    static async getAllWebViews(locators) {
        try {
            /**
             * webviews might not be immediatelly available when VS Code boots up
             */
            await browser.$(locators.WebView.outerFrame).waitForExist({
                timeout: 5000,
                timeoutMsg: 'no webviews found'
            });
        }
        catch (err) {
            return [];
        }
        const frames = await browser.$$(locators.WebView.outerFrame);
        return frames.map((f) => (new WebView_1(locators, f)));
    }
};
WebView = WebView_1 = __decorate([
    PageDecorator(WebViewLocators)
], WebView);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV2ViVmlldy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wYWdlb2JqZWN0cy93b3JrYmVuY2gvV2ViVmlldy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ0EsT0FBTyxFQUFFLFFBQVEsRUFBRSxhQUFhLEVBQWtCLE1BQU0sYUFBYSxDQUFBO0FBQ3JFLE9BQU8sRUFBRSxPQUFPLElBQUksZUFBZSxFQUFFLE1BQU0sMEJBQTBCLENBQUE7QUFLOUQsV0FBTSxPQUFPLGVBQWIsTUFBTSxPQUFRLFNBQVEsUUFBZ0M7SUFBdEQ7O1FBQ0g7O1dBRUc7UUFDSSxlQUFVLEdBQUcsU0FBa0IsQ0FBQTtJQWtEMUMsQ0FBQztJQWhERyxJQUFJLFdBQVc7UUFDWCxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxXQUFxQixDQUFDLENBQUE7SUFDMUQsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLEtBQUssQ0FBQyxJQUFJO1FBQ2IsTUFBTSxPQUFPLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTtRQUN0QyxNQUFNLENBQUMsTUFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsWUFBWSxFQUFFLENBQUE7UUFDN0MsTUFBTSxPQUFPLENBQUMsYUFBYSxDQUFDLE1BQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFBO0lBQ3ZELENBQUM7SUFFRDs7T0FFRztJQUNJLEtBQUssQ0FBQyxLQUFLO1FBQ2QsTUFBTSxPQUFPLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFBO1FBQ2pDLE1BQU0sT0FBTyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQTtJQUNyQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFFLFFBQTBCO1FBQ25ELElBQUk7WUFDQTs7ZUFFRztZQUNILE1BQU0sT0FBTyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFVBQW9CLENBQUMsQ0FBQyxZQUFZLENBQUM7Z0JBQ2hFLE9BQU8sRUFBRSxJQUFJO2dCQUNiLFVBQVUsRUFBRSxtQkFBbUI7YUFDbEMsQ0FBQyxDQUFBO1NBQ0w7UUFBQyxPQUFPLEdBQVEsRUFBRTtZQUNmLE9BQU8sRUFBRSxDQUFBO1NBQ1o7UUFFRCxNQUFNLE1BQU0sR0FBRyxNQUFNLE9BQU8sQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxVQUFvQixDQUFDLENBQUE7UUFDdEUsT0FBTyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUNyQixJQUFJLFNBQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBd0QsQ0FBQyxDQUNsRixDQUFDLENBQUE7SUFDTixDQUFDO0NBQ0osQ0FBQTtBQXREWSxPQUFPO0lBRG5CLGFBQWEsQ0FBQyxlQUFlLENBQUM7R0FDbEIsT0FBTyxDQXNEbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGFpbmFibGVQcm9taXNlRWxlbWVudCB9IGZyb20gJ3dlYmRyaXZlcmlvJ1xuaW1wb3J0IHsgQmFzZVBhZ2UsIFBhZ2VEZWNvcmF0b3IsIElQYWdlRGVjb3JhdG9yIH0gZnJvbSAnLi4vdXRpbHMuanMnXG5pbXBvcnQgeyBXZWJWaWV3IGFzIFdlYlZpZXdMb2NhdG9ycyB9IGZyb20gJy4uLy4uL2xvY2F0b3JzLzEuNzMuMC5qcydcbmltcG9ydCB0eXBlIHsgVlNDb2RlTG9jYXRvck1hcCB9IGZyb20gJy4uL3V0aWxzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFdlYlZpZXcgZXh0ZW5kcyBJUGFnZURlY29yYXRvcjx0eXBlb2YgV2ViVmlld0xvY2F0b3JzPiB7IH1cbkBQYWdlRGVjb3JhdG9yKFdlYlZpZXdMb2NhdG9ycylcbmV4cG9ydCBjbGFzcyBXZWJWaWV3IGV4dGVuZHMgQmFzZVBhZ2U8dHlwZW9mIFdlYlZpZXdMb2NhdG9ycz4ge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlIGxvY2F0b3Iga2V5IHRvIGlkZW50aWZ5IGxvY2F0b3IgbWFwIChzZWUgbG9jYXRvcnMudHMpXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnV2ViVmlldycgYXMgY29uc3RcblxuICAgIGdldCBhY3RpdmVGcmFtZSAoKTogQ2hhaW5hYmxlUHJvbWlzZUVsZW1lbnQ8V2ViZHJpdmVySU8uRWxlbWVudD4ge1xuICAgICAgICByZXR1cm4gJCh0aGlzLl9sb2NhdG9ycy5XZWJWaWV3LmFjdGl2ZUZyYW1lIGFzIHN0cmluZylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTd2l0Y2ggV2ViRHJpdmVyIGNvbnRleHQgdG8gZ2l2ZW4gd2VidmlldyBzbyBzdWJzZXF1ZW50IGVsZW1lbnRcbiAgICAgKiBjYWxscyBhcmUgdGFyZ2V0aW5nIGVsZW1lbnRzIHdpdGhpbiB0aGUgd2Vidmlldy5cbiAgICAgKlxuICAgICAqIF9fTm90ZTpfXyBlbnN1cmUgdG8gY2FsbCBgd2Vidmlldy5jbG9zZSgpYCB0byBsZWF2ZSB0aGUgd2Vidmlld1xuICAgICAqIGNvbnRleHQgYmVmb3JlIHVzaW5nIG90aGVyIHBhZ2Ugb2JqZWN0cy5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgb3BlbiAoKSB7XG4gICAgICAgIGF3YWl0IGJyb3dzZXIuc3dpdGNoVG9GcmFtZSh0aGlzLmVsZW0pXG4gICAgICAgIGF3YWl0IChhd2FpdCB0aGlzLmFjdGl2ZUZyYW1lKS53YWl0Rm9yRXhpc3QoKVxuICAgICAgICBhd2FpdCBicm93c2VyLnN3aXRjaFRvRnJhbWUoYXdhaXQgdGhpcy5hY3RpdmVGcmFtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTd2l0Y2ggZnJvbSB0aGUgd2VidmlldyBjb250ZXh0IGJhY2sgdG8gdGhlIFZTQ29kZSBjb250ZXh0LlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBjbG9zZSAoKSB7XG4gICAgICAgIGF3YWl0IGJyb3dzZXIuc3dpdGNoVG9GcmFtZShudWxsKVxuICAgICAgICBhd2FpdCBicm93c2VyLnN3aXRjaFRvRnJhbWUobnVsbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGF2YWlsYWJsZSBXZWJWaWV3cyAoaW5jbHVkaW5nIHRoZSBvbmNlIGluIHRoZSBzaWRlYmFyIG9yIGZyb20gdGhlIGVkaXRvcilcbiAgICAgKiBAcGFyYW0gbG9jYXRvcnMgbG9jYXRvciBtYXBcbiAgICAgKiBAcmV0dXJucyBhIGxpc3Qgb2Ygd2VidmlldyBvYmplY3RzXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGdldEFsbFdlYlZpZXdzIChsb2NhdG9yczogVlNDb2RlTG9jYXRvck1hcCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiB3ZWJ2aWV3cyBtaWdodCBub3QgYmUgaW1tZWRpYXRlbGx5IGF2YWlsYWJsZSB3aGVuIFZTIENvZGUgYm9vdHMgdXBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYXdhaXQgYnJvd3Nlci4kKGxvY2F0b3JzLldlYlZpZXcub3V0ZXJGcmFtZSBhcyBzdHJpbmcpLndhaXRGb3JFeGlzdCh7XG4gICAgICAgICAgICAgICAgdGltZW91dDogNTAwMCxcbiAgICAgICAgICAgICAgICB0aW1lb3V0TXNnOiAnbm8gd2Vidmlld3MgZm91bmQnXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmcmFtZXMgPSBhd2FpdCBicm93c2VyLiQkKGxvY2F0b3JzLldlYlZpZXcub3V0ZXJGcmFtZSBhcyBzdHJpbmcpXG4gICAgICAgIHJldHVybiBmcmFtZXMubWFwKChmKSA9PiAoXG4gICAgICAgICAgICBuZXcgV2ViVmlldyhsb2NhdG9ycywgZiBhcyBhbnkgYXMgQ2hhaW5hYmxlUHJvbWlzZUVsZW1lbnQ8V2ViZHJpdmVySU8uRWxlbWVudD4pXG4gICAgICAgICkpXG4gICAgfVxufVxuIl19