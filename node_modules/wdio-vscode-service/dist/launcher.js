import os from 'node:os';
import fs from 'node:fs/promises';
import path from 'node:path';
import { format } from 'node:util';
import downloadBundle from 'download';
import logger from '@wdio/logger';
import { setGlobalDispatcher, request, ProxyAgent } from 'undici';
import { download } from '@vscode/test-electron';
import { SevereServiceError } from 'webdriverio';
import { launcher as ChromedriverServiceLauncher } from 'wdio-chromedriver-service';
import { HttpsProxyAgent } from 'hpagent';
import startServer from './server/index.js';
import { validatePlatform, fileExist, directoryExists, isMultiremote, isChrome } from './utils.js';
import { DEFAULT_CHANNEL, VSCODE_RELEASES, VSCODE_MANIFEST_URL, CHROMEDRIVER_RELEASES, CHROMEDRIVER_DOWNLOAD_PATH, DEFAULT_CACHE_PATH, VSCODE_CAPABILITY_KEY, VSCODE_WEB_STANDALONE, DEFAULT_VSCODE_WEB_HOSTNAME } from './constants.js';
// set up proxy if environment variable HTTPS_PROXY or https_proxy is set
let downloadAgentConfiguration;
const httpsProxy = process.env.HTTPS_PROXY || process.env.https_proxy || process.env.npm_config_proxy;
if (httpsProxy) {
    const proxyUrl = new URL(httpsProxy);
    const token = proxyUrl.username && proxyUrl.password
        ? `Basic ${btoa(`${proxyUrl.username}:${proxyUrl.password}`)}`
        : undefined;
    setGlobalDispatcher(new ProxyAgent({ uri: proxyUrl.protocol + proxyUrl.host, token }));
    downloadAgentConfiguration = { agent: new HttpsProxyAgent({ proxy: proxyUrl }) };
}
// use HTTPS_PROXY or https_proxy for @vscode/test-electron if not already set
if (httpsProxy !== process.env.npm_config_proxy) {
    process.env.npm_config_proxy = httpsProxy;
}
const VERSIONS_TXT = 'versions.txt';
const log = logger('wdio-vscode-service/launcher');
export default class VSCodeServiceLauncher extends ChromedriverServiceLauncher {
    constructor(_options, _capabilities, config) {
        super(_options, _capabilities, config);
        this._options = _options;
        this._capabilities = _capabilities;
        this._cachePath = this._options.cachePath || DEFAULT_CACHE_PATH;
        this._mapCapabilities = () => { };
    }
    // @ts-expect-error this service uses provided params
    async onPrepare(_, capabilities) {
        const caps = Array.isArray(capabilities)
            ? capabilities.map((c) => (c.alwaysMatch || c))
            : Object.values(capabilities).map((c) => c.capabilities);
        /**
         * check if for given version we already have all bundles
         * and continue without download if possible
         */
        const versionsFilePath = path.join(this._cachePath, VERSIONS_TXT);
        const versionsFileExist = await fileExist(versionsFilePath);
        for (const cap of caps) {
            /**
             * skip setup if user is not using VSCode as capability
             */
            if (typeof cap.browserName !== 'string' || !cap[VSCODE_CAPABILITY_KEY]) {
                continue;
            }
            const version = cap[VSCODE_CAPABILITY_KEY].version || cap.browserVersion || DEFAULT_CHANNEL;
            /**
             * setup VSCode Desktop
             */
            if (cap.browserName === 'vscode') {
                await this._setupVSCodeDesktop(versionsFileExist, versionsFilePath, version, cap);
                continue;
            }
            /**
             * setup VSCode Web
             */
            await this._setupVSCodeWeb(version, cap);
            this._mapBrowserCapabilities(this.options);
        }
        return super.onPrepare();
    }
    /**
     * Set up VSCode for web testing
     * @param versionsFileExist true if we already have information stored about cached VSCode and Chromedriver bundles
     * @param versionsFilePath string with path to cached directory
     * @param cap capabilities used for this test run
     */
    async _setupVSCodeWeb(version, cap) {
        /**
         * no need to do any work if we already started the server
         */
        if (this._vscodeServerPort || !cap[VSCODE_CAPABILITY_KEY]) {
            return;
        }
        try {
            const vscodeStandalone = await this._fetchVSCodeWebStandalone(version);
            const port = await startServer(vscodeStandalone, cap[VSCODE_CAPABILITY_KEY]);
            cap[VSCODE_CAPABILITY_KEY].serverOptions = {
                ...(cap[VSCODE_CAPABILITY_KEY].serverOptions || {
                    hostname: DEFAULT_VSCODE_WEB_HOSTNAME
                }),
                port
            };
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't start server for VSCode Web: ${err.message}`);
        }
    }
    /**
     * Set up VSCode for desktop testing
     * @param versionsFileExist true if we already have information stored about cached VSCode and Chromedriver bundles
     * @param versionsFilePath string with path to cached directory
     * @param cap capabilities used for this test run
     */
    async _setupVSCodeDesktop(versionsFileExist, versionsFilePath, version, cap) {
        if (!cap[VSCODE_CAPABILITY_KEY]) {
            throw new Error(`No key "${VSCODE_CAPABILITY_KEY}" found in caps`);
        }
        if (versionsFileExist) {
            const content = JSON.parse((await fs.readFile(versionsFilePath)).toString());
            const chromedriverPath = path.join(this._cachePath, `chromedriver-${content[version]?.chromedriver}`);
            const vscodePath = (cap[VSCODE_CAPABILITY_KEY]?.binary
                || path.join(this._cachePath, `vscode-${process.platform}-${process.arch}-${content[version]?.vscode}`));
            if (content[version] && await fileExist(chromedriverPath) && await fileExist(vscodePath)) {
                log.info(`Skipping download, bundles for VSCode v${content[version]?.vscode} `
                    + `and Chromedriver v${content[version]?.chromedriver} already exist`);
                Object.assign(cap, this.options);
                cap[VSCODE_CAPABILITY_KEY].binary = (cap[VSCODE_CAPABILITY_KEY].binary
                    || await this._downloadVSCode(content[version]?.vscode));
                this.chromedriverCustomPath = chromedriverPath;
                return;
            }
        }
        const [vscodeVersion, chromedriverVersion, chromedriverPath] = await this._setupChromedriver(version);
        this.chromedriverCustomPath = chromedriverPath;
        const serviceArgs = {
            chromedriver: { version: chromedriverVersion, path: chromedriverPath },
            vscode: {
                version: vscodeVersion,
                path: cap[VSCODE_CAPABILITY_KEY]?.binary || await this._downloadVSCode(vscodeVersion)
            }
        };
        Object.assign(cap, this.options);
        cap[VSCODE_CAPABILITY_KEY].binary = serviceArgs.vscode.path;
        await this._updateVersionsTxt(version, serviceArgs, versionsFileExist);
    }
    /**
     * Downloads Chromedriver bundle for given VSCode version
     * @param desiredReleaseChannel either release channel (e.g. "stable" or "insiders")
     *                              or a concrete version e.g. 1.66.0
     * @returns "insiders" if `desiredReleaseChannel` is set to this otherwise a concrete version
     */
    async _setupChromedriver(desiredReleaseChannel) {
        const version = await this._fetchVSCodeVersion(desiredReleaseChannel);
        try {
            const chromedriverVersion = await this._fetchChromedriverVersion(version);
            log.info(`Download Chromedriver (v${chromedriverVersion})`);
            await downloadBundle(format(CHROMEDRIVER_DOWNLOAD_PATH, chromedriverVersion, validatePlatform(chromedriverVersion)), this._cachePath, { extract: true, strip: 1, ...downloadAgentConfiguration });
            const ext = os.platform().startsWith('win') ? '.exe' : '';
            const chromedriverPath = path.join(this._cachePath, `chromedriver-${chromedriverVersion}${ext}`);
            await fs.rename(path.join(this._cachePath, `chromedriver${ext}`), chromedriverPath);
            /**
             * return 'insiders' if desired release channel
             */
            return version === 'main'
                ? [desiredReleaseChannel, chromedriverVersion, chromedriverPath]
                : [version, chromedriverVersion, chromedriverPath];
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't set up Chromedriver ${err.message}`);
        }
    }
    /**
     * Download VSCode bundle
     * @param version VSCode version
     * @returns path to downloaded VSCode bundle
     */
    async _downloadVSCode(version) {
        try {
            log.info(`Download VSCode binary (${version})`);
            return await download({
                cachePath: this._cachePath,
                version
            });
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't set up VSCode: ${err.message}`);
        }
    }
    /**
     * Get VSCode version based on desired channel or validate version if provided
     * @param desiredReleaseChannel either release channel (e.g. "stable" or "insiders")
     *                              or a concrete version e.g. 1.66.0
     * @returns "main" if `desiredReleaseChannel` is "insiders" otherwise a concrete VSCode version
     */
    async _fetchVSCodeVersion(desiredReleaseChannel) {
        if (desiredReleaseChannel === 'insiders') {
            return 'main';
        }
        try {
            log.info(`Fetch releases from ${VSCODE_RELEASES}`);
            const { body: versions } = await request(VSCODE_RELEASES, {});
            const availableVersions = await versions.json();
            if (desiredReleaseChannel) {
                /**
                 * validate provided VSCode version
                 */
                const newDesiredReleaseChannel = desiredReleaseChannel === 'stable'
                    ? availableVersions[0]
                    : desiredReleaseChannel;
                if (!availableVersions.includes(newDesiredReleaseChannel)) {
                    throw new Error(`Desired version "${newDesiredReleaseChannel}" is not existent, available versions:`
                        + `${availableVersions.slice(0, 5).join(', ')}..., see ${VSCODE_RELEASES}`);
                }
                return newDesiredReleaseChannel;
            }
            return availableVersions[0];
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't fetch latest VSCode: ${err.message}`);
        }
    }
    /**
     * Fetches required Chromedriver version for given VSCode version
     * @param vscodeVersion branch or tag version of VSCode repository
     * @returns required Chromedriver version
     */
    async _fetchChromedriverVersion(vscodeVersion) {
        try {
            const { body } = await request(format(VSCODE_MANIFEST_URL, vscodeVersion), {});
            const manifest = await body.json();
            const chromium = manifest.registrations.find((r) => r.component.git.name === 'chromium');
            if (!chromium) {
                throw new Error('Can\'t find chromium version in manifest response');
            }
            const { body: chromedriverVersion } = await request(format(CHROMEDRIVER_RELEASES, chromium.version.split('.')[0]), {});
            return await chromedriverVersion.text();
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't fetch Chromedriver version: ${err.message}`);
        }
    }
    /**
     * Fetches VSCode Web files
     * ToDo(Christian): allow to define a local VSCode development path
     *                  to be able to skip this part
     */
    async _fetchVSCodeWebStandalone(vscodeVersion) {
        if (vscodeVersion !== 'stable' && vscodeVersion !== 'insiders') {
            throw new Error('Running VSCode in the browser is only supported for "stable" and "insiders" version');
        }
        try {
            const { body } = await request(format(VSCODE_WEB_STANDALONE, vscodeVersion), {});
            const info = await body.json();
            const folder = path.join(this._cachePath, `vscode-web-${vscodeVersion}-${info.version}`);
            if (!(await directoryExists(folder))) {
                await downloadBundle(info.url, folder, { extract: true, strip: 1, ...downloadAgentConfiguration });
            }
            return { path: folder, vscodeVersion, version: info.version };
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't set up VSCode Web: ${err.message}`);
        }
    }
    async _updateVersionsTxt(version, serviceArgs, versionsFileExist) {
        const newContent = {
            [version]: {
                chromedriver: serviceArgs.chromedriver.version,
                vscode: serviceArgs.vscode.version
            }
        };
        const versionsTxtPath = path.join(this._cachePath, VERSIONS_TXT);
        if (!versionsFileExist) {
            return fs.writeFile(versionsTxtPath, JSON.stringify(newContent, null, 4), 'utf-8');
        }
        const content = JSON.parse((await fs.readFile(versionsTxtPath, 'utf-8')).toString());
        return fs.writeFile(versionsTxtPath, JSON.stringify({ ...content, ...newContent }, null, 4), 'utf-8');
    }
    _mapBrowserCapabilities(options) {
        if (isMultiremote(this._capabilities)) {
            throw new SevereServiceError('This service deson\'t support multiremote yet');
        }
        for (const cap of this._capabilities) {
            if (isChrome(cap)) {
                Object.assign(cap, options);
            }
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF1bmNoZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbGF1bmNoZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sU0FBUyxDQUFBO0FBQ3hCLE9BQU8sRUFBRSxNQUFNLGtCQUFrQixDQUFBO0FBQ2pDLE9BQU8sSUFBSSxNQUFNLFdBQVcsQ0FBQTtBQUM1QixPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sV0FBVyxDQUFBO0FBRWxDLE9BQU8sY0FBbUMsTUFBTSxVQUFVLENBQUE7QUFDMUQsT0FBTyxNQUFNLE1BQU0sY0FBYyxDQUFBO0FBQ2pDLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sUUFBUSxDQUFBO0FBQ2pFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQTtBQUNoRCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxhQUFhLENBQUE7QUFDaEQsT0FBTyxFQUFFLFFBQVEsSUFBSSwyQkFBMkIsRUFBRSxNQUFNLDJCQUEyQixDQUFBO0FBRW5GLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxTQUFTLENBQUE7QUFFekMsT0FBTyxXQUFXLE1BQU0sbUJBQW1CLENBQUE7QUFDM0MsT0FBTyxFQUNILGdCQUFnQixFQUFFLFNBQVMsRUFBRSxlQUFlLEVBQUUsYUFBYSxFQUMzRCxRQUFRLEVBQ1gsTUFBTSxZQUFZLENBQUE7QUFDbkIsT0FBTyxFQUNILGVBQWUsRUFBRSxlQUFlLEVBQUUsbUJBQW1CLEVBQUUscUJBQXFCLEVBQzVFLDBCQUEwQixFQUFFLGtCQUFrQixFQUFFLHFCQUFxQixFQUNyRSxxQkFBcUIsRUFBRSwyQkFBMkIsRUFDckQsTUFBTSxnQkFBZ0IsQ0FBQTtBQXVCdkIseUVBQXlFO0FBQ3pFLElBQUksMEJBQWdFLENBQUE7QUFDcEUsTUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLElBQUksT0FBTyxD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bXBvcnQgZnMgZnJvbSAnbm9kZTpmcy9wcm9taXNlcydcbmltcG9ydCBwYXRoIGZyb20gJ25vZGU6cGF0aCdcbmltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ25vZGU6dXRpbCdcblxuaW1wb3J0IGRvd25sb2FkQnVuZGxlLCB7IERvd25sb2FkT3B0aW9ucyB9IGZyb20gJ2Rvd25sb2FkJ1xuaW1wb3J0IGxvZ2dlciBmcm9tICdAd2Rpby9sb2dnZXInXG5pbXBvcnQgeyBzZXRHbG9iYWxEaXNwYXRjaGVyLCByZXF1ZXN0LCBQcm94eUFnZW50IH0gZnJvbSAndW5kaWNpJ1xuaW1wb3J0IHsgZG93bmxvYWQgfSBmcm9tICdAdnNjb2RlL3Rlc3QtZWxlY3Ryb24nXG5pbXBvcnQgeyBTZXZlcmVTZXJ2aWNlRXJyb3IgfSBmcm9tICd3ZWJkcml2ZXJpbydcbmltcG9ydCB7IGxhdW5jaGVyIGFzIENocm9tZWRyaXZlclNlcnZpY2VMYXVuY2hlciB9IGZyb20gJ3dkaW8tY2hyb21lZHJpdmVyLXNlcnZpY2UnXG5pbXBvcnQgdHlwZSB7IE9wdGlvbnMsIENhcGFiaWxpdGllcyB9IGZyb20gJ0B3ZGlvL3R5cGVzJ1xuaW1wb3J0IHsgSHR0cHNQcm94eUFnZW50IH0gZnJvbSAnaHBhZ2VudCdcblxuaW1wb3J0IHN0YXJ0U2VydmVyIGZyb20gJy4vc2VydmVyL2luZGV4LmpzJ1xuaW1wb3J0IHtcbiAgICB2YWxpZGF0ZVBsYXRmb3JtLCBmaWxlRXhpc3QsIGRpcmVjdG9yeUV4aXN0cywgaXNNdWx0aXJlbW90ZSxcbiAgICBpc0Nocm9tZVxufSBmcm9tICcuL3V0aWxzLmpzJ1xuaW1wb3J0IHtcbiAgICBERUZBVUxUX0NIQU5ORUwsIFZTQ09ERV9SRUxFQVNFUywgVlNDT0RFX01BTklGRVNUX1VSTCwgQ0hST01FRFJJVkVSX1JFTEVBU0VTLFxuICAgIENIUk9NRURSSVZFUl9ET1dOTE9BRF9QQVRILCBERUZBVUxUX0NBQ0hFX1BBVEgsIFZTQ09ERV9DQVBBQklMSVRZX0tFWSxcbiAgICBWU0NPREVfV0VCX1NUQU5EQUxPTkUsIERFRkFVTFRfVlNDT0RFX1dFQl9IT1NUTkFNRVxufSBmcm9tICcuL2NvbnN0YW50cy5qcydcbmltcG9ydCB0eXBlIHtcbiAgICBTZXJ2aWNlT3B0aW9ucywgU2VydmljZUNhcGFiaWxpdHksIFZTQ29kZUNhcGFiaWxpdGllcywgV2ViU3RhbmRhbG9uZVJlc3BvbnNlLFxuICAgIEJ1bmRsZVxufSBmcm9tICcuL3R5cGVzJ1xuXG5pbnRlcmZhY2UgQnVuZGVJbmZvcm1hdGlvbiB7XG4gICAgY2hyb21lZHJpdmVyOiBzdHJpbmdcbiAgICB2c2NvZGU6IHN0cmluZ1xufVxuaW50ZXJmYWNlIE1hbmlmZXN0IHtcbiAgICByZWdpc3RyYXRpb25zOiBSZWdpc3RyYXRpb25bXVxufVxuaW50ZXJmYWNlIFJlZ2lzdHJhdGlvbiB7XG4gICAgdmVyc2lvbjogc3RyaW5nXG4gICAgY29tcG9uZW50OiB7XG4gICAgICAgIGdpdDoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgIH1cbiAgICB9XG59XG50eXBlIFZlcnNpb25zID0geyBbZGVzaXJlZFZlcnNpb246IHN0cmluZ106IEJ1bmRlSW5mb3JtYXRpb24gfCB1bmRlZmluZWQgfVxuXG4vLyBzZXQgdXAgcHJveHkgaWYgZW52aXJvbm1lbnQgdmFyaWFibGUgSFRUUFNfUFJPWFkgb3IgaHR0cHNfcHJveHkgaXMgc2V0XG5sZXQgZG93bmxvYWRBZ2VudENvbmZpZ3VyYXRpb246IFBhcnRpYWw8RG93bmxvYWRPcHRpb25zPiB8IHVuZGVmaW5lZFxuY29uc3QgaHR0cHNQcm94eSA9IHByb2Nlc3MuZW52LkhUVFBTX1BST1hZIHx8IHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5IHx8IHByb2Nlc3MuZW52Lm5wbV9jb25maWdfcHJveHlcbmlmIChodHRwc1Byb3h5KSB7XG4gICAgY29uc3QgcHJveHlVcmwgPSBuZXcgVVJMKGh0dHBzUHJveHkpXG4gICAgY29uc3QgdG9rZW4gPSBwcm94eVVybC51c2VybmFtZSAmJiBwcm94eVVybC5wYXNzd29yZFxuICAgICAgICA/IGBCYXNpYyAke2J0b2EoYCR7cHJveHlVcmwudXNlcm5hbWV9OiR7cHJveHlVcmwucGFzc3dvcmR9YCl9YFxuICAgICAgICA6IHVuZGVmaW5lZFxuXG4gICAgc2V0R2xvYmFsRGlzcGF0Y2hlcihuZXcgUHJveHlBZ2VudCh7IHVyaTogcHJveHlVcmwucHJvdG9jb2wgKyBwcm94eVVybC5ob3N0LCB0b2tlbiB9KSlcbiAgICBkb3dubG9hZEFnZW50Q29uZmlndXJhdGlvbiA9IHsgYWdlbnQ6IG5ldyBIdHRwc1Byb3h5QWdlbnQoeyBwcm94eTogcHJveHlVcmwgfSkgfVxufVxuLy8gdXNlIEhUVFBTX1BST1hZIG9yIGh0dHBzX3Byb3h5IGZvciBAdnNjb2RlL3Rlc3QtZWxlY3Ryb24gaWYgbm90IGFscmVhZHkgc2V0XG5pZiAoaHR0cHNQcm94eSAhPT0gcHJvY2Vzcy5lbnYubnBtX2NvbmZpZ19wcm94eSkge1xuICAgIHByb2Nlc3MuZW52Lm5wbV9jb25maWdfcHJveHkgPSBodHRwc1Byb3h5XG59XG5cbmNvbnN0IFZFUlNJT05TX1RYVCA9ICd2ZXJzaW9ucy50eHQnXG5jb25zdCBsb2cgPSBsb2dnZXIoJ3dkaW8tdnNjb2RlLXNlcnZpY2UvbGF1bmNoZXInKVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVlNDb2RlU2VydmljZUxhdW5jaGVyIGV4dGVuZHMgQ2hyb21lZHJpdmVyU2VydmljZUxhdW5jaGVyIHtcbiAgICBwcml2YXRlIF9jYWNoZVBhdGg6IHN0cmluZ1xuICAgIHByaXZhdGUgX3ZzY29kZVNlcnZlclBvcnQ/OiBudW1iZXJcblxuICAgIGNvbnN0cnVjdG9yIChcbiAgICAgICAgcHJpdmF0ZSBfb3B0aW9uczogU2VydmljZU9wdGlvbnMsXG4gICAgICAgIHByaXZhdGUgX2NhcGFiaWxpdGllczogQ2FwYWJpbGl0aWVzLkNhcGFiaWxpdGllcyxcbiAgICAgICAgY29uZmlnOiBPcHRpb25zLlRlc3RydW5uZXJcbiAgICApIHtcbiAgICAgICAgc3VwZXIoX29wdGlvbnMsIF9jYXBhYmlsaXRpZXMsIGNvbmZpZylcbiAgICAgICAgdGhpcy5fY2FjaGVQYXRoID0gdGhpcy5fb3B0aW9ucy5jYWNoZVBhdGggfHwgREVGQVVMVF9DQUNIRV9QQVRIXG4gICAgICAgIHRoaXMuX21hcENhcGFiaWxpdGllcyA9ICgpID0+IHt9XG4gICAgfVxuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGlzIHNlcnZpY2UgdXNlcyBwcm92aWRlZCBwYXJhbXNcbiAgICBhc3luYyBvblByZXBhcmUgKF86IG5ldmVyLCBjYXBhYmlsaXRpZXM6IENhcGFiaWxpdGllcy5SZW1vdGVDYXBhYmlsaXRpZXMpIHtcbiAgICAgICAgY29uc3QgY2FwczogVlNDb2RlQ2FwYWJpbGl0aWVzW10gPSBBcnJheS5pc0FycmF5KGNhcGFiaWxpdGllcylcbiAgICAgICAgICAgID8gY2FwYWJpbGl0aWVzLm1hcCgoYykgPT4gKChjIGFzIENhcGFiaWxpdGllcy5XM0NDYXBhYmlsaXRpZXMpLmFsd2F5c01hdGNoIHx8IGMpIGFzIFZTQ29kZUNhcGFiaWxpdGllcylcbiAgICAgICAgICAgIDogT2JqZWN0LnZhbHVlcyhjYXBhYmlsaXRpZXMpLm1hcCgoYykgPT4gYy5jYXBhYmlsaXRpZXMgYXMgVlNDb2RlQ2FwYWJpbGl0aWVzKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGVjayBpZiBmb3IgZ2l2ZW4gdmVyc2lvbiB3ZSBhbHJlYWR5IGhhdmUgYWxsIGJ1bmRsZXNcbiAgICAgICAgICogYW5kIGNvbnRpbnVlIHdpdGhvdXQgZG93bmxvYWQgaWYgcG9zc2libGVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHZlcnNpb25zRmlsZVBhdGggPSBwYXRoLmpvaW4odGhpcy5fY2FjaGVQYXRoLCBWRVJTSU9OU19UWFQpXG4gICAgICAgIGNvbnN0IHZlcnNpb25zRmlsZUV4aXN0ID0gYXdhaXQgZmlsZUV4aXN0KHZlcnNpb25zRmlsZVBhdGgpXG5cbiAgICAgICAgZm9yIChjb25zdCBjYXAgb2YgY2Fwcykge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBza2lwIHNldHVwIGlmIHVzZXIgaXMgbm90IHVzaW5nIFZTQ29kZSBhcyBjYXBhYmlsaXR5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FwLmJyb3dzZXJOYW1lICE9PSAnc3RyaW5nJyB8fCAhY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0udmVyc2lvbiB8fCBjYXAuYnJvd3NlclZlcnNpb24gfHwgREVGQVVMVF9DSEFOTkVMXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogc2V0dXAgVlNDb2RlIERlc2t0b3BcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGNhcC5icm93c2VyTmFtZSA9PT0gJ3ZzY29kZScpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFZTQ29kZURlc2t0b3AodmVyc2lvbnNGaWxlRXhpc3QsIHZlcnNpb25zRmlsZVBhdGgsIHZlcnNpb24sIGNhcClcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHNldHVwIFZTQ29kZSBXZWJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBWU0NvZGVXZWIodmVyc2lvbiwgY2FwKVxuICAgICAgICAgICAgdGhpcy5fbWFwQnJvd3NlckNhcGFiaWxpdGllcyh0aGlzLm9wdGlvbnMgYXMgU2VydmljZU9wdGlvbnMpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIub25QcmVwYXJlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdXAgVlNDb2RlIGZvciB3ZWIgdGVzdGluZ1xuICAgICAqIEBwYXJhbSB2ZXJzaW9uc0ZpbGVFeGlzdCB0cnVlIGlmIHdlIGFscmVhZHkgaGF2ZSBpbmZvcm1hdGlvbiBzdG9yZWQgYWJvdXQgY2FjaGVkIFZTQ29kZSBhbmQgQ2hyb21lZHJpdmVyIGJ1bmRsZXNcbiAgICAgKiBAcGFyYW0gdmVyc2lvbnNGaWxlUGF0aCBzdHJpbmcgd2l0aCBwYXRoIHRvIGNhY2hlZCBkaXJlY3RvcnlcbiAgICAgKiBAcGFyYW0gY2FwIGNhcGFiaWxpdGllcyB1c2VkIGZvciB0aGlzIHRlc3QgcnVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBfc2V0dXBWU0NvZGVXZWIgKFxuICAgICAgICB2ZXJzaW9uOiBzdHJpbmcsXG4gICAgICAgIGNhcDogVlNDb2RlQ2FwYWJpbGl0aWVzXG4gICAgKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBubyBuZWVkIHRvIGRvIGFueSB3b3JrIGlmIHdlIGFscmVhZHkgc3RhcnRlZCB0aGUgc2VydmVyXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5fdnNjb2RlU2VydmVyUG9ydCB8fCAhY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0pIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZzY29kZVN0YW5kYWxvbmUgPSBhd2FpdCB0aGlzLl9mZXRjaFZTQ29kZVdlYlN0YW5kYWxvbmUodmVyc2lvbilcbiAgICAgICAgICAgIGNvbnN0IHBvcnQgPSBhd2FpdCBzdGFydFNlcnZlcih2c2NvZGVTdGFuZGFsb25lLCBjYXBbVlNDT0RFX0NBUEFCSUxJVFlfS0VZXSlcbiAgICAgICAgICAgIGNhcFtWU0NPREVfQ0FQQUJJTElUWV9LRVldLnNlcnZlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgLi4uKGNhcFtWU0NPREVfQ0FQQUJJTElUWV9LRVldLnNlcnZlck9wdGlvbnMgfHwge1xuICAgICAgICAgICAgICAgICAgICBob3N0bmFtZTogREVGQVVMVF9WU0NPREVfV0VCX0hPU1ROQU1FXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgcG9ydFxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNldmVyZVNlcnZpY2VFcnJvcihgQ291bGRuJ3Qgc3RhcnQgc2VydmVyIGZvciBWU0NvZGUgV2ViOiAke2Vyci5tZXNzYWdlfWApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdXAgVlNDb2RlIGZvciBkZXNrdG9wIHRlc3RpbmdcbiAgICAgKiBAcGFyYW0gdmVyc2lvbnNGaWxlRXhpc3QgdHJ1ZSBpZiB3ZSBhbHJlYWR5IGhhdmUgaW5mb3JtYXRpb24gc3RvcmVkIGFib3V0IGNhY2hlZCBWU0NvZGUgYW5kIENocm9tZWRyaXZlciBidW5kbGVzXG4gICAgICogQHBhcmFtIHZlcnNpb25zRmlsZVBhdGggc3RyaW5nIHdpdGggcGF0aCB0byBjYWNoZWQgZGlyZWN0b3J5XG4gICAgICogQHBhcmFtIGNhcCBjYXBhYmlsaXRpZXMgdXNlZCBmb3IgdGhpcyB0ZXN0IHJ1blxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgX3NldHVwVlNDb2RlRGVza3RvcCAoXG4gICAgICAgIHZlcnNpb25zRmlsZUV4aXN0OiBib29sZWFuLFxuICAgICAgICB2ZXJzaW9uc0ZpbGVQYXRoOiBzdHJpbmcsXG4gICAgICAgIHZlcnNpb246IHN0cmluZyxcbiAgICAgICAgY2FwOiBWU0NvZGVDYXBhYmlsaXRpZXNcbiAgICApIHtcbiAgICAgICAgaWYgKCFjYXBbVlNDT0RFX0NBUEFCSUxJVFlfS0VZXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBrZXkgXCIke1ZTQ09ERV9DQVBBQklMSVRZX0tFWX1cIiBmb3VuZCBpbiBjYXBzYClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2ZXJzaW9uc0ZpbGVFeGlzdCkge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IEpTT04ucGFyc2UoKGF3YWl0IGZzLnJlYWRGaWxlKHZlcnNpb25zRmlsZVBhdGgpKS50b1N0cmluZygpKSBhcyBWZXJzaW9uc1xuICAgICAgICAgICAgY29uc3QgY2hyb21lZHJpdmVyUGF0aCA9IHBhdGguam9pbih0aGlzLl9jYWNoZVBhdGgsIGBjaHJvbWVkcml2ZXItJHtjb250ZW50W3ZlcnNpb25dPy5jaHJvbWVkcml2ZXJ9YClcbiAgICAgICAgICAgIGNvbnN0IHZzY29kZVBhdGggPSAoXG4gICAgICAgICAgICAgICAgY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0/LmJpbmFyeVxuICAgICAgICAgICAgICAgIHx8IHBhdGguam9pbih0aGlzLl9jYWNoZVBhdGgsIGB2c2NvZGUtJHtwcm9jZXNzLnBsYXRmb3JtfS0ke3Byb2Nlc3MuYXJjaH0tJHtjb250ZW50W3ZlcnNpb25dPy52c2NvZGV9YClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGlmIChjb250ZW50W3ZlcnNpb25dICYmIGF3YWl0IGZpbGVFeGlzdChjaHJvbWVkcml2ZXJQYXRoKSAmJiBhd2FpdCBmaWxlRXhpc3QodnNjb2RlUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBsb2cuaW5mbyhcbiAgICAgICAgICAgICAgICAgICAgYFNraXBwaW5nIGRvd25sb2FkLCBidW5kbGVzIGZvciBWU0NvZGUgdiR7Y29udGVudFt2ZXJzaW9uXT8udnNjb2RlfSBgXG4gICAgICAgICAgICAgICAgICAgICsgYGFuZCBDaHJvbWVkcml2ZXIgdiR7Y29udGVudFt2ZXJzaW9uXT8uY2hyb21lZHJpdmVyfSBhbHJlYWR5IGV4aXN0YFxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY2FwLCB0aGlzLm9wdGlvbnMpXG4gICAgICAgICAgICAgICAgY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0uYmluYXJ5ID0gKFxuICAgICAgICAgICAgICAgICAgICBjYXBbVlNDT0RFX0NBUEFCSUxJVFlfS0VZXS5iaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgfHwgYXdhaXQgdGhpcy5fZG93bmxvYWRWU0NvZGUoY29udGVudFt2ZXJzaW9uXT8udnNjb2RlIGFzIHN0cmluZylcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdGhpcy5jaHJvbWVkcml2ZXJDdXN0b21QYXRoID0gY2hyb21lZHJpdmVyUGF0aFxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgW3ZzY29kZVZlcnNpb24sIGNocm9tZWRyaXZlclZlcnNpb24sIGNocm9tZWRyaXZlclBhdGhdID0gYXdhaXQgdGhpcy5fc2V0dXBDaHJvbWVkcml2ZXIodmVyc2lvbilcbiAgICAgICAgdGhpcy5jaHJvbWVkcml2ZXJDdXN0b21QYXRoID0gY2hyb21lZHJpdmVyUGF0aFxuICAgICAgICBjb25zdCBzZXJ2aWNlQXJnczogU2VydmljZUNhcGFiaWxpdHkgPSB7XG4gICAgICAgICAgICBjaHJvbWVkcml2ZXI6IHsgdmVyc2lvbjogY2hyb21lZHJpdmVyVmVyc2lvbiwgcGF0aDogY2hyb21lZHJpdmVyUGF0aCB9LFxuICAgICAgICAgICAgdnNjb2RlOiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdnNjb2RlVmVyc2lvbixcbiAgICAgICAgICAgICAgICBwYXRoOiBjYXBbVlNDT0RFX0NBUEFCSUxJVFlfS0VZXT8uYmluYXJ5IHx8IGF3YWl0IHRoaXMuX2Rvd25sb2FkVlNDb2RlKHZzY29kZVZlcnNpb24pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbihjYXAsIHRoaXMub3B0aW9ucylcbiAgICAgICAgY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0uYmluYXJ5ID0gc2VydmljZUFyZ3MudnNjb2RlLnBhdGhcbiAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlVmVyc2lvbnNUeHQodmVyc2lvbiwgc2VydmljZUFyZ3MsIHZlcnNpb25zRmlsZUV4aXN0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBDaHJvbWVkcml2ZXIgYnVuZGxlIGZvciBnaXZlbiBWU0NvZGUgdmVyc2lvblxuICAgICAqIEBwYXJhbSBkZXNpcmVkUmVsZWFzZUNoYW5uZWwgZWl0aGVyIHJlbGVhc2UgY2hhbm5lbCAoZS5nLiBcInN0YWJsZVwiIG9yIFwiaW5zaWRlcnNcIilcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGEgY29uY3JldGUgdmVyc2lvbiBlLmcuIDEuNjYuMFxuICAgICAqIEByZXR1cm5zIFwiaW5zaWRlcnNcIiBpZiBgZGVzaXJlZFJlbGVhc2VDaGFubmVsYCBpcyBzZXQgdG8gdGhpcyBvdGhlcndpc2UgYSBjb25jcmV0ZSB2ZXJzaW9uXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBfc2V0dXBDaHJvbWVkcml2ZXIgKGRlc2lyZWRSZWxlYXNlQ2hhbm5lbDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBhd2FpdCB0aGlzLl9mZXRjaFZTQ29kZVZlcnNpb24oZGVzaXJlZFJlbGVhc2VDaGFubmVsKVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjaHJvbWVkcml2ZXJWZXJzaW9uID0gYXdhaXQgdGhpcy5fZmV0Y2hDaHJvbWVkcml2ZXJWZXJzaW9uKHZlcnNpb24pXG5cbiAgICAgICAgICAgIGxvZy5pbmZvKGBEb3dubG9hZCBDaHJvbWVkcml2ZXIgKHYke2Nocm9tZWRyaXZlclZlcnNpb259KWApXG4gICAgICAgICAgICBhd2FpdCBkb3dubG9hZEJ1bmRsZShcbiAgICAgICAgICAgICAgICBmb3JtYXQoQ0hST01FRFJJVkVSX0RPV05MT0FEX1BBVEgsIGNocm9tZWRyaXZlclZlcnNpb24sIHZhbGlkYXRlUGxhdGZvcm0oY2hyb21lZHJpdmVyVmVyc2lvbikpLFxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlUGF0aCxcbiAgICAgICAgICAgICAgICB7IGV4dHJhY3Q6IHRydWUsIHN0cmlwOiAxLCAuLi5kb3dubG9hZEFnZW50Q29uZmlndXJhdGlvbiB9XG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGNvbnN0IGV4dCA9IG9zLnBsYXRmb3JtKCkuc3RhcnRzV2l0aCgnd2luJykgPyAnLmV4ZScgOiAnJ1xuICAgICAgICAgICAgY29uc3QgY2hyb21lZHJpdmVyUGF0aCA9IHBhdGguam9pbih0aGlzLl9jYWNoZVBhdGgsIGBjaHJvbWVkcml2ZXItJHtjaHJvbWVkcml2ZXJWZXJzaW9ufSR7ZXh0fWApXG4gICAgICAgICAgICBhd2FpdCBmcy5yZW5hbWUocGF0aC5qb2luKHRoaXMuX2NhY2hlUGF0aCwgYGNocm9tZWRyaXZlciR7ZXh0fWApLCBjaHJvbWVkcml2ZXJQYXRoKVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJldHVybiAnaW5zaWRlcnMnIGlmIGRlc2lyZWQgcmVsZWFzZSBjaGFubmVsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uID09PSAnbWFpbidcbiAgICAgICAgICAgICAgICA/IFtkZXNpcmVkUmVsZWFzZUNoYW5uZWwsIGNocm9tZWRyaXZlclZlcnNpb24sIGNocm9tZWRyaXZlclBhdGhdXG4gICAgICAgICAgICAgICAgOiBbdmVyc2lvbiwgY2hyb21lZHJpdmVyVmVyc2lvbiwgY2hyb21lZHJpdmVyUGF0aF1cbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXZlcmVTZXJ2aWNlRXJyb3IoYENvdWxkbid0IHNldCB1cCBDaHJvbWVkcml2ZXIgJHtlcnIubWVzc2FnZX1gKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG93bmxvYWQgVlNDb2RlIGJ1bmRsZVxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFZTQ29kZSB2ZXJzaW9uXG4gICAgICogQHJldHVybnMgcGF0aCB0byBkb3dubG9hZGVkIFZTQ29kZSBidW5kbGVcbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIF9kb3dubG9hZFZTQ29kZSAodmVyc2lvbjogc3RyaW5nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2cuaW5mbyhgRG93bmxvYWQgVlNDb2RlIGJpbmFyeSAoJHt2ZXJzaW9ufSlgKVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGRvd25sb2FkKHtcbiAgICAgICAgICAgICAgICBjYWNoZVBhdGg6IHRoaXMuX2NhY2hlUGF0aCxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNldmVyZVNlcnZpY2VFcnJvcihgQ291bGRuJ3Qgc2V0IHVwIFZTQ29kZTogJHtlcnIubWVzc2FnZX1gKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IFZTQ29kZSB2ZXJzaW9uIGJhc2VkIG9uIGRlc2lyZWQgY2hhbm5lbCBvciB2YWxpZGF0ZSB2ZXJzaW9uIGlmIHByb3ZpZGVkXG4gICAgICogQHBhcmFtIGRlc2lyZWRSZWxlYXNlQ2hhbm5lbCBlaXRoZXIgcmVsZWFzZSBjaGFubmVsIChlLmcuIFwic3RhYmxlXCIgb3IgXCJpbnNpZGVyc1wiKVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgYSBjb25jcmV0ZSB2ZXJzaW9uIGUuZy4gMS42Ni4wXG4gICAgICogQHJldHVybnMgXCJtYWluXCIgaWYgYGRlc2lyZWRSZWxlYXNlQ2hhbm5lbGAgaXMgXCJpbnNpZGVyc1wiIG90aGVyd2lzZSBhIGNvbmNyZXRlIFZTQ29kZSB2ZXJzaW9uXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBfZmV0Y2hWU0NvZGVWZXJzaW9uIChkZXNpcmVkUmVsZWFzZUNoYW5uZWw/OiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKGRlc2lyZWRSZWxlYXNlQ2hhbm5lbCA9PT0gJ2luc2lkZXJzJykge1xuICAgICAgICAgICAgcmV0dXJuICdtYWluJ1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvZy5pbmZvKGBGZXRjaCByZWxlYXNlcyBmcm9tICR7VlNDT0RFX1JFTEVBU0VTfWApXG4gICAgICAgICAgICBjb25zdCB7IGJvZHk6IHZlcnNpb25zIH0gPSBhd2FpdCByZXF1ZXN0KFZTQ09ERV9SRUxFQVNFUywge30pXG4gICAgICAgICAgICBjb25zdCBhdmFpbGFibGVWZXJzaW9uczogc3RyaW5nW10gPSBhd2FpdCB2ZXJzaW9ucy5qc29uKCkgYXMgc3RyaW5nW11cblxuICAgICAgICAgICAgaWYgKGRlc2lyZWRSZWxlYXNlQ2hhbm5lbCkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIHZhbGlkYXRlIHByb3ZpZGVkIFZTQ29kZSB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RGVzaXJlZFJlbGVhc2VDaGFubmVsID0gZGVzaXJlZFJlbGVhc2VDaGFubmVsID09PSAnc3RhYmxlJ1xuICAgICAgICAgICAgICAgICAgICA/IGF2YWlsYWJsZVZlcnNpb25zWzBdXG4gICAgICAgICAgICAgICAgICAgIDogZGVzaXJlZFJlbGVhc2VDaGFubmVsXG4gICAgICAgICAgICAgICAgaWYgKCFhdmFpbGFibGVWZXJzaW9ucy5pbmNsdWRlcyhuZXdEZXNpcmVkUmVsZWFzZUNoYW5uZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBEZXNpcmVkIHZlcnNpb24gXCIke25ld0Rlc2lyZWRSZWxlYXNlQ2hhbm5lbH1cIiBpcyBub3QgZXhpc3RlbnQsIGF2YWlsYWJsZSB2ZXJzaW9uczpgXG4gICAgICAgICAgICAgICAgICAgICAgICArIGAke2F2YWlsYWJsZVZlcnNpb25zLnNsaWNlKDAsIDUpLmpvaW4oJywgJyl9Li4uLCBzZWUgJHtWU0NPREVfUkVMRUFTRVN9YFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0Rlc2lyZWRSZWxlYXNlQ2hhbm5lbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXZhaWxhYmxlVmVyc2lvbnNbMF1cbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXZlcmVTZXJ2aWNlRXJyb3IoYENvdWxkbid0IGZldGNoIGxhdGVzdCBWU0NvZGU6ICR7ZXJyLm1lc3NhZ2V9YClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgcmVxdWlyZWQgQ2hyb21lZHJpdmVyIHZlcnNpb24gZm9yIGdpdmVuIFZTQ29kZSB2ZXJzaW9uXG4gICAgICogQHBhcmFtIHZzY29kZVZlcnNpb24gYnJhbmNoIG9yIHRhZyB2ZXJzaW9uIG9mIFZTQ29kZSByZXBvc2l0b3J5XG4gICAgICogQHJldHVybnMgcmVxdWlyZWQgQ2hyb21lZHJpdmVyIHZlcnNpb25cbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIF9mZXRjaENocm9tZWRyaXZlclZlcnNpb24gKHZzY29kZVZlcnNpb246IHN0cmluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBib2R5IH0gPSBhd2FpdCByZXF1ZXN0KGZvcm1hdChWU0NPREVfTUFOSUZFU1RfVVJMLCB2c2NvZGVWZXJzaW9uKSwge30pXG4gICAgICAgICAgICBjb25zdCBtYW5pZmVzdCA9IGF3YWl0IGJvZHkuanNvbigpIGFzIE1hbmlmZXN0XG4gICAgICAgICAgICBjb25zdCBjaHJvbWl1bSA9IG1hbmlmZXN0LnJlZ2lzdHJhdGlvbnMuZmluZCgocjogYW55KSA9PiByLmNvbXBvbmVudC5naXQubmFtZSA9PT0gJ2Nocm9taXVtJylcblxuICAgICAgICAgICAgaWYgKCFjaHJvbWl1bSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBmaW5kIGNocm9taXVtIHZlcnNpb24gaW4gbWFuaWZlc3QgcmVzcG9uc2UnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB7IGJvZHk6IGNocm9tZWRyaXZlclZlcnNpb24gfSA9IGF3YWl0IHJlcXVlc3QoXG4gICAgICAgICAgICAgICAgZm9ybWF0KENIUk9NRURSSVZFUl9SRUxFQVNFUywgY2hyb21pdW0udmVyc2lvbi5zcGxpdCgnLicpWzBdKSxcbiAgICAgICAgICAgICAgICB7fVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGNocm9tZWRyaXZlclZlcnNpb24udGV4dCgpXG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2V2ZXJlU2VydmljZUVycm9yKGBDb3VsZG4ndCBmZXRjaCBDaHJvbWVkcml2ZXIgdmVyc2lvbjogJHtlcnIubWVzc2FnZX1gKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBWU0NvZGUgV2ViIGZpbGVzXG4gICAgICogVG9EbyhDaHJpc3RpYW4pOiBhbGxvdyB0byBkZWZpbmUgYSBsb2NhbCBWU0NvZGUgZGV2ZWxvcG1lbnQgcGF0aFxuICAgICAqICAgICAgICAgICAgICAgICAgdG8gYmUgYWJsZSB0byBza2lwIHRoaXMgcGFydFxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgX2ZldGNoVlNDb2RlV2ViU3RhbmRhbG9uZSAodnNjb2RlVmVyc2lvbjogc3RyaW5nKTogUHJvbWlzZTxCdW5kbGU+IHtcbiAgICAgICAgaWYgKHZzY29kZVZlcnNpb24gIT09ICdzdGFibGUnICYmIHZzY29kZVZlcnNpb24gIT09ICdpbnNpZGVycycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUnVubmluZyBWU0NvZGUgaW4gdGhlIGJyb3dzZXIgaXMgb25seSBzdXBwb3J0ZWQgZm9yIFwic3RhYmxlXCIgYW5kIFwiaW5zaWRlcnNcIiB2ZXJzaW9uJylcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGJvZHkgfSA9IGF3YWl0IHJlcXVlc3QoZm9ybWF0KFZTQ09ERV9XRUJfU1RBTkRBTE9ORSwgdnNjb2RlVmVyc2lvbiksIHt9KVxuICAgICAgICAgICAgY29uc3QgaW5mbyA9IGF3YWl0IGJvZHkuanNvbigpIGFzIFdlYlN0YW5kYWxvbmVSZXNwb25zZVxuICAgICAgICAgICAgY29uc3QgZm9sZGVyID0gcGF0aC5qb2luKHRoaXMuX2NhY2hlUGF0aCwgYHZzY29kZS13ZWItJHt2c2NvZGVWZXJzaW9ufS0ke2luZm8udmVyc2lvbn1gKVxuXG4gICAgICAgICAgICBpZiAoIShhd2FpdCBkaXJlY3RvcnlFeGlzdHMoZm9sZGVyKSkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBkb3dubG9hZEJ1bmRsZShpbmZvLnVybCwgZm9sZGVyLCB7IGV4dHJhY3Q6IHRydWUsIHN0cmlwOiAxLCAuLi5kb3dubG9hZEFnZW50Q29uZmlndXJhdGlvbiB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyBwYXRoOiBmb2xkZXIsIHZzY29kZVZlcnNpb24sIHZlcnNpb246IGluZm8udmVyc2lvbiB9XG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2V2ZXJlU2VydmljZUVycm9yKGBDb3VsZG4ndCBzZXQgdXAgVlNDb2RlIFdlYjogJHtlcnIubWVzc2FnZX1gKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfdXBkYXRlVmVyc2lvbnNUeHQgKHZlcnNpb246IHN0cmluZywgc2VydmljZUFyZ3M6IFNlcnZpY2VDYXBhYmlsaXR5LCB2ZXJzaW9uc0ZpbGVFeGlzdDogYm9vbGVhbikge1xuICAgICAgICBjb25zdCBuZXdDb250ZW50OiBWZXJzaW9ucyA9IHtcbiAgICAgICAgICAgIFt2ZXJzaW9uXToge1xuICAgICAgICAgICAgICAgIGNocm9tZWRyaXZlcjogc2VydmljZUFyZ3MuY2hyb21lZHJpdmVyLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgdnNjb2RlOiBzZXJ2aWNlQXJncy52c2NvZGUudmVyc2lvblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZlcnNpb25zVHh0UGF0aCA9IHBhdGguam9pbih0aGlzLl9jYWNoZVBhdGgsIFZFUlNJT05TX1RYVClcbiAgICAgICAgaWYgKCF2ZXJzaW9uc0ZpbGVFeGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZzLndyaXRlRmlsZShcbiAgICAgICAgICAgICAgICB2ZXJzaW9uc1R4dFBhdGgsXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobmV3Q29udGVudCwgbnVsbCwgNCksXG4gICAgICAgICAgICAgICAgJ3V0Zi04J1xuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udGVudCA9IEpTT04ucGFyc2UoKGF3YWl0IGZzLnJlYWRGaWxlKHZlcnNpb25zVHh0UGF0aCwgJ3V0Zi04JykpLnRvU3RyaW5nKCkpXG4gICAgICAgIHJldHVybiBmcy53cml0ZUZpbGUoXG4gICAgICAgICAgICB2ZXJzaW9uc1R4dFBhdGgsXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7IC4uLmNvbnRlbnQsIC4uLm5ld0NvbnRlbnQgfSwgbnVsbCwgNCksXG4gICAgICAgICAgICAndXRmLTgnXG4gICAgICAgIClcbiAgICB9XG5cbiAgICBwcml2YXRlIF9tYXBCcm93c2VyQ2FwYWJpbGl0aWVzIChvcHRpb25zOiBTZXJ2aWNlT3B0aW9ucykge1xuICAgICAgICBpZiAoaXNNdWx0aXJlbW90ZSh0aGlzLl9jYXBhYmlsaXRpZXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2V2ZXJlU2VydmljZUVycm9yKCdUaGlzIHNlcnZpY2UgZGVzb25cXCd0IHN1cHBvcnQgbXVsdGlyZW1vdGUgeWV0JylcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgY2FwIG9mIHRoaXMuX2NhcGFiaWxpdGllcyBhcyBhbnkgYXMgQ2FwYWJpbGl0aWVzLkNhcGFiaWxpdGllc1tdKSB7XG4gICAgICAgICAgICBpZiAoaXNDaHJvbWUoY2FwKSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY2FwLCBvcHRpb25zKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIl19